1
00:00:00,000 --> 00:00:02,670
>> [THEME MUSIC]

2
00:00:02,670 --> 00:00:11,834

3
00:00:11,834 --> 00:00:13,365
>> SPEAKER 1: Hi, everyone.

4
00:00:13,365 --> 00:00:14,365
Welcome back to section.

5
00:00:14,365 --> 00:00:15,700

6
00:00:15,700 --> 00:00:18,700
Lovely day out-- which is why, I'm
sure, there are only four of you here

7
00:00:18,700 --> 00:00:21,180
and not our usual pack.

8
00:00:21,180 --> 00:00:22,670
I have been sick this weekend.

9
00:00:22,670 --> 00:00:24,294
So I don't have Starburst for you guys.

10
00:00:24,294 --> 00:00:26,400
And I may start coughing
terribly throughout this.

11
00:00:26,400 --> 00:00:27,790
So just bear with me.

12
00:00:27,790 --> 00:00:30,624
I'm going to really try
and get through this first,

13
00:00:30,624 --> 00:00:32,290
though, before I have a coughing attack.

14
00:00:32,290 --> 00:00:33,410

15
00:00:33,410 --> 00:00:37,390
But just be easy on me a
little bit-- that's all I ask.

16
00:00:37,390 --> 00:00:39,370

17
00:00:39,370 --> 00:00:44,289
>> So our agenda for today-- just a
reminder-- your quiz is next week.

18
00:00:44,289 --> 00:00:46,830
I told you this last week so it
wouldn't catch you off guard.

19
00:00:46,830 --> 00:00:47,954
So I'm reminding you again.

20
00:00:47,954 --> 00:00:49,180
Next week's your quiz.

21
00:00:49,180 --> 00:00:52,730
To that end, next week's
section will be much more

22
00:00:52,730 --> 00:00:55,180
of-- I'll try and work in some review.

23
00:00:55,180 --> 00:00:58,130
So if you guys could
help me out by sending me

24
00:00:58,130 --> 00:01:00,990
things that you're comfortable
with, that you're worried about,

25
00:01:00,990 --> 00:01:03,530
topics that you'd like for
me to cover, that'd be great.

26
00:01:03,530 --> 00:01:05,740
So I can try and work them
into our section next week

27
00:01:05,740 --> 00:01:11,540
or send you extra material or prep
that you might not get elsewhere.

28
00:01:11,540 --> 00:01:12,150
>> Yeah!

29
00:01:12,150 --> 00:01:13,520
More people are coming!

30
00:01:13,520 --> 00:01:17,320
I thought, did I do that badly last
week, that no one wants to come back?

31
00:01:17,320 --> 00:01:18,065
I'm scared.

32
00:01:18,065 --> 00:01:18,892

33
00:01:18,892 --> 00:01:21,100
So the other three things
that we're going to go over

34
00:01:21,100 --> 00:01:24,850
are redirection, file I/O, and
then pointers and dynamic memory.

35
00:01:24,850 --> 00:01:29,160
I'm sure you're all super excited about
pointers-- everyone's favorite topic,

36
00:01:29,160 --> 00:01:31,310
so simple to understand.

37
00:01:31,310 --> 00:01:33,130
I'm sure you guys all got that, right?

38
00:01:33,130 --> 00:01:39,510
>> So first things first, redirection--
this is basically just a way

39
00:01:39,510 --> 00:01:42,920
to control how you input
things into your program,

40
00:01:42,920 --> 00:01:44,606
how you output things from your program.

41
00:01:44,606 --> 00:01:46,980
The main ways that you guys
have been interacting with it

42
00:01:46,980 --> 00:01:51,650
is just through standard out
with your print screen here.

43
00:01:51,650 --> 00:01:55,940
But there are ways to
pipe-- as we see here

44
00:01:55,940 --> 00:01:58,980
is one of our words-- kind
of pipe that information

45
00:01:58,980 --> 00:02:02,850
or that data into a file from a file.

46
00:02:02,850 --> 00:02:05,820
It's just different ways of
getting things into your program

47
00:02:05,820 --> 00:02:10,681
and out of your program, instead of
just printing them to this screen

48
00:02:10,681 --> 00:02:12,430
or inputting things
from the command line.

49
00:02:12,430 --> 00:02:13,760

50
00:02:13,760 --> 00:02:18,030
>> So first one is little
greater than caret.

51
00:02:18,030 --> 00:02:22,085
So output-- it just prints the output
to a file instead of your screen.

52
00:02:22,085 --> 00:02:23,620

53
00:02:23,620 --> 00:02:29,500
So if you had something that printed
"Hello, world!" to the screen,

54
00:02:29,500 --> 00:02:32,400
if you put it instead
to output.text, that

55
00:02:32,400 --> 00:02:35,220
creates this file called output.text.

56
00:02:35,220 --> 00:02:38,550
And when you open it, it'll
say "Hello, world!" in there.

57
00:02:38,550 --> 00:02:41,410
This can be super useful
if you have a ton of errors

58
00:02:41,410 --> 00:02:43,430
actually, as we see in this one.

59
00:02:43,430 --> 00:02:46,810
If you do two caret, it'll
print the error messages.

60
00:02:46,810 --> 00:02:52,090
>> So if you're having a problem with
compiling, it has a lot of errors

61
00:02:52,090 --> 00:02:56,770
and you're getting bogged down in trying
to scroll through in your command line

62
00:02:56,770 --> 00:02:59,110
through all them, you can
just print them to a file,

63
00:02:59,110 --> 00:03:02,130
open up that file so that you
can scroll through them easier.

64
00:03:02,130 --> 00:03:05,160
I actually used that a
lot when I was debugging

65
00:03:05,160 --> 00:03:07,970
my 181 psets for machine learning.

66
00:03:07,970 --> 00:03:10,000
So it can be super useful later on.

67
00:03:10,000 --> 00:03:18,370
It's also useful if you have a program
that maybe is generating a library

68
00:03:18,370 --> 00:03:20,430
or generating some set
of strings, and you

69
00:03:20,430 --> 00:03:22,846
need to be able to see that
it's generating them properly.

70
00:03:22,846 --> 00:03:23,860

71
00:03:23,860 --> 00:03:25,160
This is the way to do that.

72
00:03:25,160 --> 00:03:28,280
>> So if you print them to a file, you
can more easily examine them, right?

73
00:03:28,280 --> 00:03:30,930
Versus trying to scroll
through your command line.

74
00:03:30,930 --> 00:03:32,740

75
00:03:32,740 --> 00:03:35,820
And then one thing to note
is that with just the greater

76
00:03:35,820 --> 00:03:40,090
than caret, if you are writing
to a file that already exists--

77
00:03:40,090 --> 00:03:44,990
so like if we ran this the first
time, we put it to output.text,

78
00:03:44,990 --> 00:03:49,970
and then we had a second program
that printed this as program two

79
00:03:49,970 --> 00:03:54,250
and did a greater than to output.text,
it will overwrite that-- so

80
00:03:54,250 --> 00:03:56,715
overwrite what was ever in
that file to begin with.

81
00:03:56,715 --> 00:03:57,720

82
00:03:57,720 --> 00:04:00,750
>> So if you want to append
to a file, as we see here,

83
00:04:00,750 --> 00:04:04,779
you just do two greater than signs.

84
00:04:04,779 --> 00:04:05,820
And it will append to it.

85
00:04:05,820 --> 00:04:06,750
It won't overwrite it.

86
00:04:06,750 --> 00:04:09,770
So if you need to run multiple
programs and kind of keep

87
00:04:09,770 --> 00:04:13,170
track of what all of them are
returning to you in a file,

88
00:04:13,170 --> 00:04:14,190
that's a way to do it.

89
00:04:14,190 --> 00:04:17,231
If you don't care what's in your file
and it's allowed to be overwritten,

90
00:04:17,231 --> 00:04:19,204
you can just use a single greater than.

91
00:04:19,204 --> 00:04:20,600
Does that make sense to everyone?

92
00:04:20,600 --> 00:04:23,205

93
00:04:23,205 --> 00:04:31,140
>> AUDIENCE: Like dot slash hello greater
than output dot text, like twice,

94
00:04:31,140 --> 00:04:34,030
it'll just only show on output
dot text a second time--

95
00:04:34,030 --> 00:04:34,810
>> SPEAKER 1: Right.

96
00:04:34,810 --> 00:04:40,450
So it would basically just completely
overwrite what was there to begin with.

97
00:04:40,450 --> 00:04:44,260
If this file here, the
output.text already

98
00:04:44,260 --> 00:04:48,230
exists, basically whatever you call
that again with a single greater

99
00:04:48,230 --> 00:04:51,920
than you can just think of it
as like it replaced the file.

100
00:04:51,920 --> 00:04:54,824
Like when you're saving a Word
document and you do save as,

101
00:04:54,824 --> 00:04:57,365
and you keep the same name, and
it completely overwrites it--

102
00:04:57,365 --> 00:04:58,680
this is the same sort of thing.

103
00:04:58,680 --> 00:05:00,380

104
00:05:00,380 --> 00:05:03,550
Anyone have any questions on
just outputting to a file?

105
00:05:03,550 --> 00:05:05,051

106
00:05:05,051 --> 00:05:05,550
Awesome.

107
00:05:05,550 --> 00:05:11,440
>> So obviously, if you reverse the
arrow direction, it can do input.

108
00:05:11,440 --> 00:05:13,090

109
00:05:13,090 --> 00:05:19,960
So when you guys had
like Caesar or Visioneer

110
00:05:19,960 --> 00:05:23,195
and you had to input something,
you had a command line argument

111
00:05:23,195 --> 00:05:24,960
that actually input it.

112
00:05:24,960 --> 00:05:27,410
This is another way to do that.

113
00:05:27,410 --> 00:05:30,520
So instead of waiting
for a command prompt,

114
00:05:30,520 --> 00:05:33,800
like when you asked for your
message in Caesar or Visioneer,

115
00:05:33,800 --> 00:05:36,490
if you had a text file
that had your message,

116
00:05:36,490 --> 00:05:38,280
you could just type it into that.

117
00:05:38,280 --> 00:05:44,930
>> So if this were like dot slash Caesar
3 less than arrow input text, which

118
00:05:44,930 --> 00:05:47,240
is your message, that
would run just fine.

119
00:05:47,240 --> 00:05:51,310

120
00:05:51,310 --> 00:05:54,020
When your Caesar program actually
asked for input from the user,

121
00:05:54,020 --> 00:05:57,360
it would already have it because
you've typed in this file.

122
00:05:57,360 --> 00:05:58,830
That's just another way.

123
00:05:58,830 --> 00:06:02,445
Just a reverse of output--
just input for your data.

124
00:06:02,445 --> 00:06:04,570

125
00:06:04,570 --> 00:06:06,680
>> And then the last one is pipe.

126
00:06:06,680 --> 00:06:07,780
So this one's pretty cool.

127
00:06:07,780 --> 00:06:09,890
Because it allows you to
take the output of one

128
00:06:09,890 --> 00:06:13,695
program and put it as
input to another program.

129
00:06:13,695 --> 00:06:15,250

130
00:06:15,250 --> 00:06:18,630
I don't know if any of you
played with the decipher

131
00:06:18,630 --> 00:06:20,590
that CS50 might have
given you, but it would

132
00:06:20,590 --> 00:06:27,380
allow you to take some sample
file, type it into your encryption,

133
00:06:27,380 --> 00:06:30,350
and then from there type
that into your decryption

134
00:06:30,350 --> 00:06:32,470
to make sure it turned out the same.

135
00:06:32,470 --> 00:06:34,050
So it's kind of like three-way loop.

136
00:06:34,050 --> 00:06:38,400

137
00:06:38,400 --> 00:06:39,423
Go for it.

138
00:06:39,423 --> 00:06:41,785
>> AUDIENCE: If a program
has multiple inputs,

139
00:06:41,785 --> 00:06:47,646
is there a way to tell it which input
to use the text file or the output for?

140
00:06:47,646 --> 00:06:49,325
>> SPEAKER 1: It has multiple inputs.

141
00:06:49,325 --> 00:06:52,190

142
00:06:52,190 --> 00:07:00,430
Whatever file your input-- when it's
asking for input that first time, it's

143
00:07:00,430 --> 00:07:03,240
going to assume, I think, it's
going to pipe in the entire file.

144
00:07:03,240 --> 00:07:03,979

145
00:07:03,979 --> 00:07:07,145
So if you have multiple inputs, you're
going to be piping in multiple files.

146
00:07:07,145 --> 00:07:08,190

147
00:07:08,190 --> 00:07:12,390
So if you're asking for messages
three times in your code,

148
00:07:12,390 --> 00:07:15,230
you're going to be putting
in three different files.

149
00:07:15,230 --> 00:07:15,980
And it gets crazy.

150
00:07:15,980 --> 00:07:18,188
And you shouldn't have to
worry about that right now.

151
00:07:18,188 --> 00:07:19,150
But that's the idea.

152
00:07:19,150 --> 00:07:20,680

153
00:07:20,680 --> 00:07:26,822
>> So yeah, pipe is just output of one
program uses input into the other.

154
00:07:26,822 --> 00:07:27,665
Everyone good there?

155
00:07:27,665 --> 00:07:28,565

156
00:07:28,565 --> 00:07:29,065
Cool.

157
00:07:29,065 --> 00:07:30,170

158
00:07:30,170 --> 00:07:30,932
OK.

159
00:07:30,932 --> 00:07:32,890
You probably won't have
to do too much with it.

160
00:07:32,890 --> 00:07:35,670
But you should understand
ways you can use this.

161
00:07:35,670 --> 00:07:38,910
And there are some cases that
you might want to use it.

162
00:07:38,910 --> 00:07:44,590
>> So file I/O-- I know what you're
saying-- we're used to reading from

163
00:07:44,590 --> 00:07:50,500
and writing to our screen there,
which is standard in and standard out.

164
00:07:50,500 --> 00:07:54,370
And that's what you guys have been
doing since the beginning of class here.

165
00:07:54,370 --> 00:07:58,220
But you can also read and write files,
which is all file I/O-- so file input,

166
00:07:58,220 --> 00:07:59,850
output is all it stands for.

167
00:07:59,850 --> 00:08:00,930

168
00:08:00,930 --> 00:08:04,360
So this basically means that
you can store your data now.

169
00:08:04,360 --> 00:08:08,460
>> When you just print it to the
screen, it's basically gone, right?

170
00:08:08,460 --> 00:08:12,507
As soon as you make "Hello
world" and run "Hello world"

171
00:08:12,507 --> 00:08:14,090
it prints "Hello world" to the screen.

172
00:08:14,090 --> 00:08:16,370
But you can't really do
anything with it from there.

173
00:08:16,370 --> 00:08:18,950
If you store in a text
file, then suddenly

174
00:08:18,950 --> 00:08:22,789
you have this data that you're allowed
to manipulate or put it into a file,

175
00:08:22,789 --> 00:08:24,080
or put it into a program later.

176
00:08:24,080 --> 00:08:26,370

177
00:08:26,370 --> 00:08:29,290
One of the reasons
why we do this is just

178
00:08:29,290 --> 00:08:31,560
as a way to store data for later use.

179
00:08:31,560 --> 00:08:34,790

180
00:08:34,790 --> 00:08:37,279
>> I have a couple of steps here
just walking through standard

181
00:08:37,279 --> 00:08:39,450
I/O. In step one, you
need to create a reference

182
00:08:39,450 --> 00:08:43,480
to the file with all
caps FILE star file.

183
00:08:43,480 --> 00:08:45,740
So that creates a pointer to a file.

184
00:08:45,740 --> 00:08:48,080

185
00:08:48,080 --> 00:08:49,650
So then you want to open it.

186
00:08:49,650 --> 00:08:52,940
And you say, literally,
just file equals fopen.

187
00:08:52,940 --> 00:08:57,400
And this is going to return a
pointer to the file you just opened.

188
00:08:57,400 --> 00:08:59,610

189
00:08:59,610 --> 00:09:01,460
I saw a couple of you
guys at office hours.

190
00:09:01,460 --> 00:09:07,400
>> But one of the things
is remember-- pointers

191
00:09:07,400 --> 00:09:10,409
can be some address or null, right?

192
00:09:10,409 --> 00:09:12,700
If we ever have a case where
something can return null,

193
00:09:12,700 --> 00:09:14,990
what do we have to do
before we ever use it?

194
00:09:14,990 --> 00:09:16,220

195
00:09:16,220 --> 00:09:19,000
We need to check if
it's null or not, right?

196
00:09:19,000 --> 00:09:23,600
Because some of you may have had
the issue where whatever object

197
00:09:23,600 --> 00:09:26,110
was being returned in breakout was null.

198
00:09:26,110 --> 00:09:28,170
You tried to perform
some function on it.

199
00:09:28,170 --> 00:09:29,770
And your computer site faulted.

200
00:09:29,770 --> 00:09:30,725
Right?

201
00:09:30,725 --> 00:09:33,640
I bet a couple of you
may have had that issue.

202
00:09:33,640 --> 00:09:38,890
>> So with fopen, fopen will either
return a pointer to the file,

203
00:09:38,890 --> 00:09:41,200
or if something goes wrong,
it's going to return null.

204
00:09:41,200 --> 00:09:45,980
So you always need to check
that it has not returned null

205
00:09:45,980 --> 00:09:47,880
before you attempt to do anything else.

206
00:09:47,880 --> 00:09:49,110

207
00:09:49,110 --> 00:09:51,974
This is like a standard paradigm
that you're going to need here.

208
00:09:51,974 --> 00:09:54,390
If there's ever a chance that
something could return null,

209
00:09:54,390 --> 00:09:56,590
check to make sure it
doesn't before you proceed.

210
00:09:56,590 --> 00:09:58,911
Otherwise, you're going
to get lovely site faults.

211
00:09:58,911 --> 00:10:00,410
And no one likes to deal with those.

212
00:10:00,410 --> 00:10:03,180

213
00:10:03,180 --> 00:10:06,410
>> So as we see here, the first argument
is just the path to the file.

214
00:10:06,410 --> 00:10:09,380
If that file doesn't exist,
it's going to create that file.

215
00:10:09,380 --> 00:10:10,713
And it's just going to be blank.

216
00:10:10,713 --> 00:10:10,789

217
00:10:10,789 --> 00:10:13,080
And then the second argument
is the mode that you want.

218
00:10:13,080 --> 00:10:14,610
Do we want to read from this file?

219
00:10:14,610 --> 00:10:15,560
Do you want to write from it?

220
00:10:15,560 --> 00:10:16,476
Do you want to append?

221
00:10:16,476 --> 00:10:17,600

222
00:10:17,600 --> 00:10:20,670
So actually what I just said--
if the file doesn't exist

223
00:10:20,670 --> 00:10:23,400
and you're trying to read from
it, it's going to throw an error.

224
00:10:23,400 --> 00:10:26,890
If the file name-- like if
file.text doesn't exist yet

225
00:10:26,890 --> 00:10:29,250
and you want to write
to it, it will create

226
00:10:29,250 --> 00:10:33,110
a blank file called file.text for you.

227
00:10:33,110 --> 00:10:36,612
And if you want to append,
you should do the same thing.

228
00:10:36,612 --> 00:10:38,081
Does that make sense?

229
00:10:38,081 --> 00:10:40,580
If you're trying to read from
a file that doesn't exist yet,

230
00:10:40,580 --> 00:10:41,590
it'll throw an error.

231
00:10:41,590 --> 00:10:44,340
Otherwise, it will create the file
for you do what you want to it.

232
00:10:44,340 --> 00:10:45,970

233
00:10:45,970 --> 00:10:46,470
Cool.

234
00:10:46,470 --> 00:10:47,510

235
00:10:47,510 --> 00:10:48,880
Now we can read from the file.

236
00:10:48,880 --> 00:10:52,570
And this is just kind of going
through the different functions

237
00:10:52,570 --> 00:10:58,980
that we have for file I/O. This will
be necessary in this week's pset,

238
00:10:58,980 --> 00:11:00,505
if I remember correctly.

239
00:11:00,505 --> 00:11:02,880
Yes, it absolutely will be
necessary in this week's pset.

240
00:11:02,880 --> 00:11:04,260

241
00:11:04,260 --> 00:11:07,010
So fgetc returns the next character.

242
00:11:07,010 --> 00:11:08,350

243
00:11:08,350 --> 00:11:10,300
fgets just returns a line of text.

244
00:11:10,300 --> 00:11:11,790

245
00:11:11,790 --> 00:11:14,610
It will return anything up to
a new line, and it will break.

246
00:11:14,610 --> 00:11:15,950

247
00:11:15,950 --> 00:11:18,700
So fread reads a certain
number of bytes and places them

248
00:11:18,700 --> 00:11:20,700
into an array, which
is something you might

249
00:11:20,700 --> 00:11:25,485
want to do with re-size--
might be useful.

250
00:11:25,485 --> 00:11:26,550

251
00:11:26,550 --> 00:11:29,290
>> How many people have read
the pset spec, by the way?

252
00:11:29,290 --> 00:11:30,980

253
00:11:30,980 --> 00:11:32,261
OK.

254
00:11:32,261 --> 00:11:32,760
[INAUDIBLE]

255
00:11:32,760 --> 00:11:35,380

256
00:11:35,380 --> 00:11:36,580
>> SPEAKER 1: OK.

257
00:11:36,580 --> 00:11:37,530
All right.

258
00:11:37,530 --> 00:11:41,940
Definitely read that-- it's a fun pset.

259
00:11:41,940 --> 00:11:51,320
You get to recover a deleted memory
card-- really exciting when it works.

260
00:11:51,320 --> 00:11:54,100
But definitely, start reading that.

261
00:11:54,100 --> 00:11:56,280
Come talk to me if you
have questions about it.

262
00:11:56,280 --> 00:11:59,290
>> OK, so as I was saying, fread
reads a certain number of bytes.

263
00:11:59,290 --> 00:12:01,340

264
00:12:01,340 --> 00:12:03,590
That's some arbitrary number
that you're going to set.

265
00:12:03,590 --> 00:12:05,990

266
00:12:05,990 --> 00:12:08,260
And then fseek just moves
to a certain position.

267
00:12:08,260 --> 00:12:11,150
So maybe you don't care
about the next 10 bytes.

268
00:12:11,150 --> 00:12:12,880
You just want to skip ahead.

269
00:12:12,880 --> 00:12:14,030
You don't care about those.

270
00:12:14,030 --> 00:12:16,280
You want to read starting at byte 11.

271
00:12:16,280 --> 00:12:18,252
fseek allows you to do that.

272
00:12:18,252 --> 00:12:20,710
So it allows you to be selective
about what you're reading.

273
00:12:20,710 --> 00:12:25,880
Because fgetc, fgets, and fread read
from a certain place in the file.

274
00:12:25,880 --> 00:12:27,260

275
00:12:27,260 --> 00:12:35,090
>> A way to think about this is if this
is our file, when you first open it,

276
00:12:35,090 --> 00:12:41,140
you have this position in file
that starts at the beginning.

277
00:12:41,140 --> 00:12:45,040
Whenever you call
fgetc, fgetf, or fread,

278
00:12:45,040 --> 00:12:48,875
it's going to start from
this position marker.

279
00:12:48,875 --> 00:12:51,340

280
00:12:51,340 --> 00:12:55,245
Let's say you just want to read
this chunk of memory over here.

281
00:12:55,245 --> 00:12:56,300

282
00:12:56,300 --> 00:12:57,960
You can't just call.

283
00:12:57,960 --> 00:13:02,430
You have to seek over here
and then read from there

284
00:13:02,430 --> 00:13:06,540
or read, gets, or getc,
depending on what you want.

285
00:13:06,540 --> 00:13:09,310
So seek just allows you to
skip portions of memory.

286
00:13:09,310 --> 00:13:11,590
And that's the only
way you can skip things

287
00:13:11,590 --> 00:13:14,012
without reading them into your buffer.

288
00:13:14,012 --> 00:13:15,470
Does that make sense to everyone?

289
00:13:15,470 --> 00:13:21,110

290
00:13:21,110 --> 00:13:24,780
>> Obviously, there's a
lot of parallel here--

291
00:13:24,780 --> 00:13:27,780
our output, or input redirection,
you have read and write.

292
00:13:27,780 --> 00:13:31,800
So fputc just writes a
character into the file.

293
00:13:31,800 --> 00:13:33,655
fputs writes a line.

294
00:13:33,655 --> 00:13:35,030

295
00:13:35,030 --> 00:13:37,420
Fprintf prints a formatted output.

296
00:13:37,420 --> 00:13:41,190
So if you have tabs,
or space, or whatnot.

297
00:13:41,190 --> 00:13:44,180
And then fwrite writes some
array of bytes to a file.

298
00:13:44,180 --> 00:13:48,860
So this is the same way
fwrite and fread are analogous

299
00:13:48,860 --> 00:13:57,550
opposites-- fgets, fputs, and
then fputc and fgetc-- lots

300
00:13:57,550 --> 00:14:00,710
of crazy, quick things.

301
00:14:00,710 --> 00:14:05,300
>> Just kind of keep this handy--
you'll have different times

302
00:14:05,300 --> 00:14:08,680
where maybe you just want
one character at a time.

303
00:14:08,680 --> 00:14:09,890
Maybe you want a whole line.

304
00:14:09,890 --> 00:14:14,320
With your dictionary pset--
which is in two psets,

305
00:14:14,320 --> 00:14:19,690
I believe, we give you a whole
dictionary in a text format

306
00:14:19,690 --> 00:14:22,252
which has every word
separated by a line.

307
00:14:22,252 --> 00:14:24,210
So if you wanted to read
in one word at a time,

308
00:14:24,210 --> 00:14:31,769
what might you use if you're reading
and they're all separated on new lines,

309
00:14:31,769 --> 00:14:33,310
and you just want one word at a time?

310
00:14:33,310 --> 00:14:35,320

311
00:14:35,320 --> 00:14:36,040
>> AUDIENCE: Fgets

312
00:14:36,040 --> 00:14:36,748
>> SPEAKER 1: Right.

313
00:14:36,748 --> 00:14:39,960
Fgets-- because that returns
whatever is on one line.

314
00:14:39,960 --> 00:14:42,750
And if every word is its
own line, we can use fgets.

315
00:14:42,750 --> 00:14:44,511

316
00:14:44,511 --> 00:14:45,010
Cool.

317
00:14:45,010 --> 00:14:47,290
Does that make sense, everyone?

318
00:14:47,290 --> 00:14:48,020
Cool?

319
00:14:48,020 --> 00:14:50,020
Yeah, we're going to get to
the fun part with pointers

320
00:14:50,020 --> 00:14:51,728
very soon, where you
get to do some math.

321
00:14:51,728 --> 00:14:52,776
And it'll be great.

322
00:14:52,776 --> 00:14:55,690

323
00:14:55,690 --> 00:14:57,740
>> Last step-- close your file.

324
00:14:57,740 --> 00:15:01,090
With so many things here,
one of our paradigms

325
00:15:01,090 --> 00:15:03,550
is if it can return
null, check for null.

326
00:15:03,550 --> 00:15:06,160
If you open something,
you'd better close it.

327
00:15:06,160 --> 00:15:10,419
OK, so you're not done until you're
done unless you've closed it.

328
00:15:10,419 --> 00:15:12,585
Kind of like it's not over
until the fat lady sings.

329
00:15:12,585 --> 00:15:14,130
That's like closing your file.

330
00:15:14,130 --> 00:15:16,860

331
00:15:16,860 --> 00:15:19,190
As it says here, just
to reiterate, always

332
00:15:19,190 --> 00:15:21,750
open your file before you're
reading or writing to it.

333
00:15:21,750 --> 00:15:24,450
And always close it if you've opened it.

334
00:15:24,450 --> 00:15:25,460
All right?

335
00:15:25,460 --> 00:15:25,960
Cool.

336
00:15:25,960 --> 00:15:26,835
>> So here's an example.

337
00:15:26,835 --> 00:15:29,250

338
00:15:29,250 --> 00:15:34,330
So tiny-- I don't know if you
guys can see that very well.

339
00:15:34,330 --> 00:15:36,805
If only we could increase
the brightness somehow.

340
00:15:36,805 --> 00:15:40,430

341
00:15:40,430 --> 00:15:45,030
Let me actually do this if I can.

342
00:15:45,030 --> 00:15:48,020

343
00:15:48,020 --> 00:15:51,470
OK, you guys can't really
see that at all, can you?

344
00:15:51,470 --> 00:15:52,905
OK, we're going to do this, then.

345
00:15:52,905 --> 00:16:35,094

346
00:16:35,094 --> 00:16:35,594
[INAUDIBLE]

347
00:16:35,594 --> 00:16:56,670

348
00:16:56,670 --> 00:16:58,605
>> I assume this is much better to see.

349
00:16:58,605 --> 00:17:17,330

350
00:17:17,330 --> 00:17:19,455
Can anyone see where my
mouse went is the question?

351
00:17:19,455 --> 00:17:22,837
Ah, there it is-- what struggles!

352
00:17:22,837 --> 00:17:48,910

353
00:17:48,910 --> 00:17:49,520
>> OK.

354
00:17:49,520 --> 00:17:53,845
Basically, you guys should have kind
of an idea of what this is doing.

355
00:17:53,845 --> 00:17:56,740

356
00:17:56,740 --> 00:17:57,600
It's not perfect.

357
00:17:57,600 --> 00:17:58,851

358
00:17:58,851 --> 00:18:02,425
But I'd rather explain it than spend
more time trying to format it properly.

359
00:18:02,425 --> 00:18:03,610

360
00:18:03,610 --> 00:18:07,280
Basically, as you see here,
we start with file open.

361
00:18:07,280 --> 00:18:09,620
And we have some
database file that we are

362
00:18:09,620 --> 00:18:12,300
opening that says it's our students.

363
00:18:12,300 --> 00:18:14,020
And we're going to write to it.

364
00:18:14,020 --> 00:18:15,060

365
00:18:15,060 --> 00:18:17,720
So of course, return null.

366
00:18:17,720 --> 00:18:19,650
So we have to check for null.

367
00:18:19,650 --> 00:18:22,930
And then if it's not
null, we go through.

368
00:18:22,930 --> 00:18:25,660
And as you see, we're
looping through here.

369
00:18:25,660 --> 00:18:26,960
There are students.

370
00:18:26,960 --> 00:18:30,520
Students is hash defined as three.

371
00:18:30,520 --> 00:18:34,060
And what we're doing is we are
printing to the file, right?

372
00:18:34,060 --> 00:18:36,975
So what are we printing out to our file?

373
00:18:36,975 --> 00:18:47,040

374
00:18:47,040 --> 00:18:48,906
>> AUDIENCE: The scores
that are in the array?

375
00:18:48,906 --> 00:18:49,680
>> SPEAKER 1: Yeah.

376
00:18:49,680 --> 00:18:50,980
The scores that are in
the array-- exactly.

377
00:18:50,980 --> 00:18:53,050
So we are opening this
database file, which

378
00:18:53,050 --> 00:18:56,040
I assume is some sort
of grades database.

379
00:18:56,040 --> 00:19:01,100
And we're just printing out the
scores of each student to that file.

380
00:19:01,100 --> 00:19:02,140
Cool?

381
00:19:02,140 --> 00:19:02,640
Good.

382
00:19:02,640 --> 00:19:03,811

383
00:19:03,811 --> 00:19:04,310
Awesome.

384
00:19:04,310 --> 00:19:05,100
OK.

385
00:19:05,100 --> 00:19:06,950
Let's get back to--

386
00:19:06,950 --> 00:19:08,646
>> AUDIENCE: I have a quick question.

387
00:19:08,646 --> 00:19:11,570
Is the printf not in the for loop?

388
00:19:11,570 --> 00:19:12,870
That's just in the if loop?

389
00:19:12,870 --> 00:19:14,370
SPEAKER 1: No, it's in the for loop.

390
00:19:14,370 --> 00:19:16,150

391
00:19:16,150 --> 00:19:18,810
I cannot see my mouse very well up here.

392
00:19:18,810 --> 00:19:21,359
So I'm struggling to
format that properly.

393
00:19:21,359 --> 00:19:22,525
This bracket should be gone.

394
00:19:22,525 --> 00:19:23,610

395
00:19:23,610 --> 00:19:25,130
It should be down here.

396
00:19:25,130 --> 00:19:26,605
This is what's in your for loop.

397
00:19:26,605 --> 00:20:10,680

398
00:20:10,680 --> 00:20:11,180
There.

399
00:20:11,180 --> 00:20:12,160
Now it's pretty.

400
00:20:12,160 --> 00:20:16,720
So that's how it should be-- except
for that last bracket that I dismissed.

401
00:20:16,720 --> 00:20:17,220
OK.

402
00:20:17,220 --> 00:20:19,491
Does that make sense to everyone?

403
00:20:19,491 --> 00:20:19,990
OK.

404
00:20:19,990 --> 00:20:23,750
We're going to move on
to the next thing then--

405
00:20:23,750 --> 00:20:26,180
which, actually, you're going
to need to see the code.

406
00:20:26,180 --> 00:20:28,370
So I'm just going to
copy that over right now.

407
00:20:28,370 --> 00:20:31,500

408
00:20:31,500 --> 00:20:32,000
OK.

409
00:20:32,000 --> 00:20:35,110
So I'm going to show you guys this code.

410
00:20:35,110 --> 00:20:38,240
And I want you to try and figure
out what it's supposed to do.

411
00:20:38,240 --> 00:20:49,740

412
00:20:49,740 --> 00:20:52,480
>> So given that-- take a minute or so.

413
00:20:52,480 --> 00:20:54,440
Try and figure out what's going on here.

414
00:20:54,440 --> 00:21:58,840

415
00:21:58,840 --> 00:21:59,570
>> Any ideas?

416
00:21:59,570 --> 00:22:08,180

417
00:22:08,180 --> 00:22:12,470
>> We know that we have at least two
arguments in the command line, right?

418
00:22:12,470 --> 00:22:16,270
I assume one of which is going to be
that [INAUDIBLE] of our program is

419
00:22:16,270 --> 00:22:17,530
and then something else.

420
00:22:17,530 --> 00:22:19,980
Because if [INAUDIBLE] is less
than two, we yell at them.

421
00:22:19,980 --> 00:22:21,140
Right?

422
00:22:21,140 --> 00:22:25,300
And from the usage, it looks like
it's going to be some sort of file.

423
00:22:25,300 --> 00:22:26,260
We all agree to that?

424
00:22:26,260 --> 00:22:29,110

425
00:22:29,110 --> 00:22:31,570
So now, what's the loop doing?

426
00:22:31,570 --> 00:22:32,570
What's it going through?

427
00:22:32,570 --> 00:22:35,000

428
00:22:35,000 --> 00:22:36,449
>> AUDIENCE: All the files.

429
00:22:36,449 --> 00:22:37,240
SPEAKER 1: Exactly.

430
00:22:37,240 --> 00:22:39,650
It's going through all the
files that we've input there.

431
00:22:39,650 --> 00:22:40,720

432
00:22:40,720 --> 00:22:46,040
So for each file, it's
opening up some string there.

433
00:22:46,040 --> 00:22:47,560
It's opening up that file.

434
00:22:47,560 --> 00:22:48,060
Right?

435
00:22:48,060 --> 00:22:49,140

436
00:22:49,140 --> 00:22:52,380
And it's reading from it.

437
00:22:52,380 --> 00:22:53,420

438
00:22:53,420 --> 00:22:55,540
Of course, checking if it's null.

439
00:22:55,540 --> 00:22:57,220
And then it's printing.

440
00:22:57,220 --> 00:23:01,460
If it's null, it's just telling us
that that's not a file that exists.

441
00:23:01,460 --> 00:23:04,290
Because remember, with
read our file has to exist.

442
00:23:04,290 --> 00:23:04,810
Right?

443
00:23:04,810 --> 00:23:06,870
With write and append,
you can get away with it.

444
00:23:06,870 --> 00:23:08,970
But with read, our file has to exist.

445
00:23:08,970 --> 00:23:10,430

446
00:23:10,430 --> 00:23:13,330
>> And then if it does exist,
what are we doing here?

447
00:23:13,330 --> 00:23:14,810

448
00:23:14,810 --> 00:23:15,780
Let's just start here.

449
00:23:15,780 --> 00:23:18,815
What's this do-- this first character.

450
00:23:18,815 --> 00:23:20,960

451
00:23:20,960 --> 00:23:21,790
What does it do?

452
00:23:21,790 --> 00:23:24,100
He gets one character, right?

453
00:23:24,100 --> 00:23:25,400
So what is this doing?

454
00:23:25,400 --> 00:23:26,775
It's getting the first character.

455
00:23:26,775 --> 00:23:28,860

456
00:23:28,860 --> 00:23:30,200
Anyone know EOF?

457
00:23:30,200 --> 00:23:31,170
>> AUDIENCE: End of file?

458
00:23:31,170 --> 00:23:32,680
>> SPEAKER 1: End of file-- exactly.

459
00:23:32,680 --> 00:23:35,310
So it's going to go through
the entire file, right?

460
00:23:35,310 --> 00:23:36,710

461
00:23:36,710 --> 00:23:40,780
And then it's going to update by
getting every subsequent character.

462
00:23:40,780 --> 00:23:41,565
Right?

463
00:23:41,565 --> 00:23:43,636
And what's it doing?

464
00:23:43,636 --> 00:23:44,760
AUDIENCE: Putting that in--

465
00:23:44,760 --> 00:23:46,741

466
00:23:46,741 --> 00:23:49,170
>> SPEAKER 1: Putchar prints
to your screensaver.

467
00:23:49,170 --> 00:23:50,867

468
00:23:50,867 --> 00:23:51,950
[INAUDIBLE] the character.

469
00:23:51,950 --> 00:23:54,300
And then when it [INAUDIBLE]
this will close the file.

470
00:23:54,300 --> 00:23:57,370
>> AUDIENCE: Do you not need an [? else? ?]

471
00:23:57,370 --> 00:23:59,005
>> SPEAKER 1: Not necessarily.

472
00:23:59,005 --> 00:24:01,480
I mean, it's kind of implied in this.

473
00:24:01,480 --> 00:24:06,780
Because this returns, though, as long
as this doesn't catch this, you're fine.

474
00:24:06,780 --> 00:24:07,940

475
00:24:07,940 --> 00:24:10,250
I mean it's probably good
practice to do an else.

476
00:24:10,250 --> 00:24:15,755
But an else is not always
necessary especially

477
00:24:15,755 --> 00:24:17,610
if you have something
like a return, which

478
00:24:17,610 --> 00:24:20,640
means that in this case if it catches
it, your program's going to end

479
00:24:20,640 --> 00:24:21,850
and it'll never get to this.

480
00:24:21,850 --> 00:24:23,030

481
00:24:23,030 --> 00:24:29,190
It's more for the case where you're
not necessarily returning something.

482
00:24:29,190 --> 00:24:31,370
Because if this wasn't
returning anything,

483
00:24:31,370 --> 00:24:34,430
it would mean that if this were true,
the rest of this would still run.

484
00:24:34,430 --> 00:24:36,138
And in that case, you
would want a false.

485
00:24:36,138 --> 00:24:38,240
If it's returning, and
your program's ending,

486
00:24:38,240 --> 00:24:41,960
an else isn't necessary all
the time, depending on context.

487
00:24:41,960 --> 00:24:43,084

488
00:24:43,084 --> 00:24:44,375
Jacob, did you have a question?

489
00:24:44,375 --> 00:24:46,100
AUDIENCE: Yeah.

490
00:24:46,100 --> 00:24:49,300
So does fgetc get the next character?

491
00:24:49,300 --> 00:24:50,734
How does the character increase?

492
00:24:50,734 --> 00:24:51,400
SPEAKER 1: Yeah.

493
00:24:51,400 --> 00:24:52,774
So fgetc gets the next character.

494
00:24:52,774 --> 00:24:54,140

495
00:24:54,140 --> 00:24:56,866
You can think of it like C++ in a sense.

496
00:24:56,866 --> 00:24:58,350
>> AUDIENCE: So what was EOF?

497
00:24:58,350 --> 00:25:00,877
>> SPEAKER 1: EOF is end of file.

498
00:25:00,877 --> 00:25:03,960
It's just a marker that lets you know
that you're at the end of your file.

499
00:25:03,960 --> 00:25:06,742
So this is going to print
to your standard out.

500
00:25:06,742 --> 00:25:08,950
And then it's going to close
the file when it's done.

501
00:25:08,950 --> 00:25:10,700
And then let's go to
the next file, right?

502
00:25:10,700 --> 00:25:12,660
So overall, what does this program do?

503
00:25:12,660 --> 00:25:15,402

504
00:25:15,402 --> 00:25:16,090
>> [INAUDIBLE]

505
00:25:16,090 --> 00:25:16,900
>> SPEAKER 1: Yeah.

506
00:25:16,900 --> 00:25:18,770
It just prints out everything there.

507
00:25:18,770 --> 00:25:23,270
So if you guys have ever used CAT
and then the name of some file--

508
00:25:23,270 --> 00:25:26,240
I don't know if any of you have
ever done that on your terminal.

509
00:25:26,240 --> 00:25:29,630
But if you ever use the
command CAT-- C-A-T--

510
00:25:29,630 --> 00:25:31,880
and then whatever file
you have there-- it

511
00:25:31,880 --> 00:25:37,260
prints it out to your terminal, which
can be super handy for some things.

512
00:25:37,260 --> 00:25:38,746
I use it a lot.

513
00:25:38,746 --> 00:25:40,120
Does that make sense to everyone?

514
00:25:40,120 --> 00:25:41,480

515
00:25:41,480 --> 00:25:42,100
Cool?

516
00:25:42,100 --> 00:25:46,530
>> OK so your task now-- either by
yourself or with the people around you--

517
00:25:46,530 --> 00:25:54,930
is to just write a simple program
that will just write "Hello, world!"

518
00:25:54,930 --> 00:25:56,255
out to a file.

519
00:25:56,255 --> 00:26:00,215
>> [INAUDIBLE]

520
00:26:00,215 --> 00:26:56,210

521
00:26:56,210 --> 00:26:57,040
>> [INAUDIBLE]

522
00:26:57,040 --> 00:26:59,248
>> SPEAKER 1: I was like, did
I do that badly last week?

523
00:26:59,248 --> 00:27:00,201

524
00:27:00,201 --> 00:27:01,492
I didn't think it was that bad.

525
00:27:01,492 --> 00:27:02,479

526
00:27:02,479 --> 00:27:03,520
I'm glad you're all here.

527
00:27:03,520 --> 00:27:04,655
It really makes me happy.

528
00:27:04,655 --> 00:27:07,565

529
00:27:07,565 --> 00:27:10,160
I'm a girl of simple pleasures.

530
00:27:10,160 --> 00:27:11,688
I just like when my section attends.

531
00:27:11,688 --> 00:27:13,830

532
00:27:13,830 --> 00:27:18,270
So I'm just getting this started for
you guys so that we can code together.

533
00:27:18,270 --> 00:27:22,290
I don't like putting anyone on
the spot unless you want to be.

534
00:27:22,290 --> 00:27:26,486

535
00:27:26,486 --> 00:27:30,086
>> AUDIENCE: For the quiz, do
we have to write a program?

536
00:27:30,086 --> 00:27:33,260
>> SPEAKER 1: You may be asked to
write simple programs by hand.

537
00:27:33,260 --> 00:27:35,940

538
00:27:35,940 --> 00:27:36,590
Yup.

539
00:27:36,590 --> 00:27:38,510
>> AUDIENCE: The quiz is next week, right?

540
00:27:38,510 --> 00:27:40,108
>> SPEAKER 1: The quiz is next Wednesday.

541
00:27:40,108 --> 00:27:40,855

542
00:27:40,855 --> 00:27:43,730
That means there's a lovely [? CSE ?]
grading party afterwards, which

543
00:27:43,730 --> 00:27:50,390
means you'll get your scores
back that night-- at what time?

544
00:27:50,390 --> 00:27:50,890
Who knows?

545
00:27:50,890 --> 00:27:51,973
But it will be that night.

546
00:27:51,973 --> 00:28:02,020

547
00:28:02,020 --> 00:28:02,855
>> All right.

548
00:28:02,855 --> 00:28:04,250
How do we want to start this?

549
00:28:04,250 --> 00:28:07,964

550
00:28:07,964 --> 00:28:09,630
I'll give you a hint-- starts with this.

551
00:28:09,630 --> 00:28:11,455
>> AUDIENCE: You have to open a file.

552
00:28:11,455 --> 00:28:12,250
>> SPEAKER 1: Yeah.

553
00:28:12,250 --> 00:28:14,060
So what do you want to call this?

554
00:28:14,060 --> 00:28:16,150
Do you just want to call it "file"?

555
00:28:16,150 --> 00:28:17,480
Let's make it easy.

556
00:28:17,480 --> 00:28:26,752
So fopen-- what's our
output test going to be?

557
00:28:26,752 --> 00:28:36,130
Call it "Hello."

558
00:28:36,130 --> 00:28:37,810
And what is our mode?

559
00:28:37,810 --> 00:28:39,764

560
00:28:39,764 --> 00:28:41,055
What are we doing to this file?

561
00:28:41,055 --> 00:28:42,676

562
00:28:42,676 --> 00:28:43,500
>> AUDIENCE: Read.

563
00:28:43,500 --> 00:28:44,401

564
00:28:44,401 --> 00:28:44,900
Writing.

565
00:28:44,900 --> 00:28:46,191
SPEAKER 1: We're writing to it.

566
00:28:46,191 --> 00:28:47,360

567
00:28:47,360 --> 00:28:47,860
Lovely.

568
00:28:47,860 --> 00:28:50,330

569
00:28:50,330 --> 00:28:52,860
OK, so we have this file now.

570
00:28:52,860 --> 00:28:54,920

571
00:28:54,920 --> 00:28:56,212
What do we need to do?

572
00:28:56,212 --> 00:28:57,420
AUDIENCE: Check if it's null.

573
00:28:57,420 --> 00:28:59,820
SPEAKER 1: Check if it's null-- exactly.

574
00:28:59,820 --> 00:29:01,980
That's what I like to hear.

575
00:29:01,980 --> 00:29:05,930
That should be automatic, especially
pretty much from this point on.

576
00:29:05,930 --> 00:29:07,530

577
00:29:07,530 --> 00:29:10,950
If you start segfaulting, you probably
didn't check for null somewhere.

578
00:29:10,950 --> 00:29:12,480
Nine times out of ten, that's
going to be your error.

579
00:29:12,480 --> 00:29:15,400
So if you could just get in the
habit, always check if it's null,

580
00:29:15,400 --> 00:29:18,150
your life's going to be
nice and easy-- or easier.

581
00:29:18,150 --> 00:29:19,480
>> So check to see if it's null.

582
00:29:19,480 --> 00:29:21,200

583
00:29:21,200 --> 00:29:24,820
So if it's not null, which
is what the bang equals

584
00:29:24,820 --> 00:29:26,784
means-- not null-- it's valid.

585
00:29:26,784 --> 00:29:27,700
What do we want to do?

586
00:29:27,700 --> 00:29:29,750

587
00:29:29,750 --> 00:29:31,570
We just want to print
to that file, right?

588
00:29:31,570 --> 00:29:32,923
So what are we going to use?

589
00:29:32,923 --> 00:29:34,092
>> AUDIENCE: Fprintf

590
00:29:34,092 --> 00:29:36,800
>> SPEAKER 1: Fprintf-- lovely.

591
00:29:36,800 --> 00:29:38,150

592
00:29:38,150 --> 00:29:44,000
And fprintf takes two arguments-- where
it's going and what we want printed.

593
00:29:44,000 --> 00:29:45,820
So what's the first one?

594
00:29:45,820 --> 00:29:46,570
Where is it going?

595
00:29:46,570 --> 00:29:47,490
>> AUDIENCE: File.

596
00:29:47,490 --> 00:29:48,785
>> SPEAKER 1: It's going to file.

597
00:29:48,785 --> 00:29:49,784

598
00:29:49,784 --> 00:29:50,950
And what do we want printed?

599
00:29:50,950 --> 00:29:52,900

600
00:29:52,900 --> 00:29:58,065
"Hello, world!"

601
00:29:58,065 --> 00:29:58,565
All right.

602
00:29:58,565 --> 00:30:03,670
We have one last thing--
another big paradigm here.

603
00:30:03,670 --> 00:30:04,479

604
00:30:04,479 --> 00:30:05,145
AUDIENCE: Close.

605
00:30:05,145 --> 00:30:05,853
SPEAKER 1: Close.

606
00:30:05,853 --> 00:30:09,990

607
00:30:09,990 --> 00:30:10,540
There you go.

608
00:30:10,540 --> 00:30:13,384
>> AUDIENCE: Is this happening
if the file is null?

609
00:30:13,384 --> 00:30:15,050
SPEAKER 1: No, this is if it's not null.

610
00:30:15,050 --> 00:30:16,881
AUDIENCE: Oh, if it's not-- OK.

611
00:30:16,881 --> 00:30:21,728

612
00:30:21,728 --> 00:30:25,410
For the fopen and then the
two arguments that go inside,

613
00:30:25,410 --> 00:30:27,655
what does the first argument mean again?

614
00:30:27,655 --> 00:30:30,392
>> SPEAKER 1: The argument is
just like the name of the file

615
00:30:30,392 --> 00:30:31,350
that you want to go to.

616
00:30:31,350 --> 00:30:36,020
So after this runs, you would
have some file called "hello"

617
00:30:36,020 --> 00:30:38,320
that had "Hello, world" within it.

618
00:30:38,320 --> 00:30:38,820
That's all.

619
00:30:38,820 --> 00:30:39,500
Just the name.

620
00:30:39,500 --> 00:30:42,685

621
00:30:42,685 --> 00:30:48,650
>> AUDIENCE: And since it's writing, the
file doesn't have to already exist.

622
00:30:48,650 --> 00:30:49,675
Is that what you said?

623
00:30:49,675 --> 00:30:50,410
>> SPEAKER 1: Right.

624
00:30:50,410 --> 00:30:50,910
Exactly.

625
00:30:50,910 --> 00:30:53,110

626
00:30:53,110 --> 00:30:55,839
If "Hello" as a file
doesn't exist yet, it's

627
00:30:55,839 --> 00:30:58,380
going to create a file called
Hello" and write to it for you.

628
00:30:58,380 --> 00:30:59,631

629
00:30:59,631 --> 00:31:03,610
>> AUDIENCE: When you're telling
the program to wrote to the file,

630
00:31:03,610 --> 00:31:08,075
why do you write "file" instead of
the name of the file and fprintf--

631
00:31:08,075 --> 00:31:13,600
>> SPEAKER 1: Because in this case, we have
that large FILE-- all in caps-- star,

632
00:31:13,600 --> 00:31:14,260
file.

633
00:31:14,260 --> 00:31:17,370
So it's a pointer to the file
that you're talking about.

634
00:31:17,370 --> 00:31:19,930
This is the way that
we just refer to it.

635
00:31:19,930 --> 00:31:24,850
So in this case, you
can think of file-- aha,

636
00:31:24,850 --> 00:31:31,271
we can use this-- file here
refers to the opening of "Hello"

637
00:31:31,271 --> 00:31:32,145
and letting it write.

638
00:31:32,145 --> 00:31:34,728
>> AUDIENCE: Could we put a "Hello"
instead [? of just ?] f file?

639
00:31:34,728 --> 00:31:40,160
SPEAKER 1: No, because "Hello"
needs to be open and writeable.

640
00:31:40,160 --> 00:31:41,820

641
00:31:41,820 --> 00:31:45,980
File here is like a
designator that says OK, we

642
00:31:45,980 --> 00:31:49,190
have this file-- hello--
that we're looking at.

643
00:31:49,190 --> 00:31:50,680
It has been opened.

644
00:31:50,680 --> 00:31:52,140
And we are going to write to it.

645
00:31:52,140 --> 00:31:55,130
If you just use "Hello",
that is encapsulated in it.

646
00:31:55,130 --> 00:31:56,846
So it's going to freak out.

647
00:31:56,846 --> 00:31:58,590

648
00:31:58,590 --> 00:32:00,300
I mean, you could have named it.

649
00:32:00,300 --> 00:32:03,960
You could have done file,
star, "Hello", equals that.

650
00:32:03,960 --> 00:32:07,840
But the whole point is that you
need a file star pointer in order

651
00:32:07,840 --> 00:32:09,281
to be able to use these functions.

652
00:32:09,281 --> 00:32:11,280
AUDIENCE: Could you do
file, star, file, "Hello"

653
00:32:11,280 --> 00:32:13,113
or do you have to put
file star, file by it?

654
00:32:13,113 --> 00:32:16,330
SPEAKER 1: You could
do file, star, "Hello."

655
00:32:16,330 --> 00:32:19,790
You can change this to
whatever name you want.

656
00:32:19,790 --> 00:32:22,114
It's completely arbitrary
what that name is.

657
00:32:22,114 --> 00:32:23,179

658
00:32:23,179 --> 00:32:24,220
You can name it anything.

659
00:32:24,220 --> 00:32:25,501

660
00:32:25,501 --> 00:32:28,020
Name it flying spaghetti, if you wanted.

661
00:32:28,020 --> 00:32:29,690
>> AUDIENCE: What is the "w" in quotes for?

662
00:32:29,690 --> 00:32:31,540
>> SPEAKER 1: The "w" is just the mode.

663
00:32:31,540 --> 00:32:33,170
So we're writing to this file.

664
00:32:33,170 --> 00:32:34,410

665
00:32:34,410 --> 00:32:35,320
Everyone good?

666
00:32:35,320 --> 00:32:36,227
Clear?

667
00:32:36,227 --> 00:32:36,981
Yes.

668
00:32:36,981 --> 00:32:40,365
>> AUDIENCE: So when it writes this
file, where do we then find that file?

669
00:32:40,365 --> 00:32:43,820
>> SPEAKER 1: It'll be in the same
directory that you're currently in.

670
00:32:43,820 --> 00:32:45,650

671
00:32:45,650 --> 00:32:48,880
If you're in pset three and
you run this, within your pset

672
00:32:48,880 --> 00:32:52,600
three folder is going to be
this file called "Hello."

673
00:32:52,600 --> 00:32:53,160
Cool?

674
00:32:53,160 --> 00:32:53,757
Everyone good?

675
00:32:53,757 --> 00:32:55,840
I feel like you're all
getting it, which is great.

676
00:32:55,840 --> 00:32:57,290

677
00:32:57,290 --> 00:32:57,790
OK.

678
00:32:57,790 --> 00:33:05,960
So back to my slide show--
I love when things work.

679
00:33:05,960 --> 00:33:08,674
OK, pointers-- Are you guys excited?

680
00:33:08,674 --> 00:33:09,465
Pointers are great.

681
00:33:09,465 --> 00:33:11,581

682
00:33:11,581 --> 00:33:13,580
They take a little bit
to wrap your head around.

683
00:33:13,580 --> 00:33:15,288
This is my second year
teaching pointers.

684
00:33:15,288 --> 00:33:16,850
And I think I finally got it.

685
00:33:16,850 --> 00:33:18,650
So if you struggle, it's OK.

686
00:33:18,650 --> 00:33:19,940

687
00:33:19,940 --> 00:33:24,070
As I said before, drawing pictures
helps a lot with things in CS,

688
00:33:24,070 --> 00:33:27,400
as much as I think people tend
to think oh, we're at a computer.

689
00:33:27,400 --> 00:33:28,399
We should just code.

690
00:33:28,399 --> 00:33:30,190
No-- drawing pictures
will really help you.

691
00:33:30,190 --> 00:33:32,773
And I really encourage you to
tap into your kindergartner side

692
00:33:32,773 --> 00:33:35,010
and bring out crayons
or markers and draw.

693
00:33:35,010 --> 00:33:36,110
Because it will help you.

694
00:33:36,110 --> 00:33:39,380
And if you see me at office hours, I
will be carrying around stacks of paper

695
00:33:39,380 --> 00:33:41,580
with pens drawing things out.

696
00:33:41,580 --> 00:33:44,370
>> So especially with
pointers-- draw pictures.

697
00:33:44,370 --> 00:33:47,970
And I'm sure we're actually going to
be drawing some pictures here too.

698
00:33:47,970 --> 00:33:51,270
>> So you guys all got to see Binky,
this cool claymation thing.

699
00:33:51,270 --> 00:33:54,720
And we think it's really funny when
he explodes into a bunch of pieces.

700
00:33:54,720 --> 00:33:56,280

701
00:33:56,280 --> 00:33:57,755
It's some comic relief for class.

702
00:33:57,755 --> 00:34:02,140

703
00:34:02,140 --> 00:34:05,900
C [INAUDIBLE] this great ability
to be able to control memory.

704
00:34:05,900 --> 00:34:10,090
And it's one of the things that really
makes it such a powerful language.

705
00:34:10,090 --> 00:34:13,469
But with great power comes
great responsibility.

706
00:34:13,469 --> 00:34:16,230
And crazy things can happen
if you're not careful.

707
00:34:16,230 --> 00:34:18,560
So when you're using
pointers, you want to make

708
00:34:18,560 --> 00:34:21,440
sure you really understand
exactly what you're doing.

709
00:34:21,440 --> 00:34:25,530
Hopefully the next little bit of
time will help you really understand

710
00:34:25,530 --> 00:34:27,850
pointers, how to use them,
and how to manipulate them.

711
00:34:27,850 --> 00:34:29,170

712
00:34:29,170 --> 00:34:33,460
>> So memory-- I'm sure we've
seen this diagram before.

713
00:34:33,460 --> 00:34:38,540
So this is just a simple diagram of
how things might be stored memory.

714
00:34:38,540 --> 00:34:43,145
So you basically have these
huge arrays of one byte blocks

715
00:34:43,145 --> 00:34:46,000
is what we have here-- slight
increments by one each time.

716
00:34:46,000 --> 00:34:51,810
This is in hex [INAUDIBLE]
so eight-bit blocks.

717
00:34:51,810 --> 00:34:55,510
And every block is associated
with some hexadecimal address.

718
00:34:55,510 --> 00:34:58,750
So if you ever see the
0x, that's just notating

719
00:34:58,750 --> 00:35:00,670
that it's a hexadecimal address.

720
00:35:00,670 --> 00:35:03,970
You can assume this means
some address in memory.

721
00:35:03,970 --> 00:35:06,935
We're talking about memory addresses
whenever you see hexadecimal.

722
00:35:06,935 --> 00:35:10,420

723
00:35:10,420 --> 00:35:14,630
>> We have ints are variables,
floats are variables that store.

724
00:35:14,630 --> 00:35:16,260
So ints store ints.

725
00:35:16,260 --> 00:35:17,430
Floats store floats.

726
00:35:17,430 --> 00:35:20,260
So we also have pointers
that store memory addresses.

727
00:35:20,260 --> 00:35:21,660
That's a sort of mapping.

728
00:35:21,660 --> 00:35:24,240
Pointers are exclusively
for memory addresses.

729
00:35:24,240 --> 00:35:25,780

730
00:35:25,780 --> 00:35:27,292
So that's like your type there.

731
00:35:27,292 --> 00:35:29,550

732
00:35:29,550 --> 00:35:34,470
Your appliance is 32-bit, which means
that your memory address is four bytes.

733
00:35:34,470 --> 00:35:37,830
So any pointer that you have
is also going to be four bytes.

734
00:35:37,830 --> 00:35:43,200
Or else if it's four bytes,
memory is four bytes.

735
00:35:43,200 --> 00:35:44,790
Pointers store memory.

736
00:35:44,790 --> 00:35:46,430
Therefore, they're four bytes.

737
00:35:46,430 --> 00:35:48,460
Cool-- just want to reinforce that.

738
00:35:48,460 --> 00:35:50,120

739
00:35:50,120 --> 00:35:52,220
>> You should get this comic now.

740
00:35:52,220 --> 00:35:55,040
I don't know how many of you
are xkcd fans, but I love xkcd.

741
00:35:55,040 --> 00:35:55,780
It's great.

742
00:35:55,780 --> 00:35:57,290

743
00:35:57,290 --> 00:35:57,790
>> All right.

744
00:35:57,790 --> 00:36:01,640
So creating pointers-- as I said, it's
pretty much just like anything else.

745
00:36:01,640 --> 00:36:02,930
You have a type.

746
00:36:02,930 --> 00:36:04,050
You have a name.

747
00:36:04,050 --> 00:36:04,810
Right?

748
00:36:04,810 --> 00:36:10,410
That's what we have there.
[? Hex ?] star means it's a pointer,

749
00:36:10,410 --> 00:36:12,250
and then whatever you want to call it.

750
00:36:12,250 --> 00:36:15,770
So the type represents
what you can store.

751
00:36:15,770 --> 00:36:16,850

752
00:36:16,850 --> 00:36:17,990
All right?

753
00:36:17,990 --> 00:36:24,350
In the same way that if we do ints,
we know we're storing an int there.

754
00:36:24,350 --> 00:36:25,990

755
00:36:25,990 --> 00:36:30,280
With a pointer, it
holds a memory address.

756
00:36:30,280 --> 00:36:34,240
But what it means is that-- here's where
a drawing is going to come in handy.

757
00:36:34,240 --> 00:36:36,170

758
00:36:36,170 --> 00:36:45,980
So in this case, we have
some value-- let's say four.

759
00:36:45,980 --> 00:36:49,306
Four is at address one.

760
00:36:49,306 --> 00:36:49,805
OK?

761
00:36:49,805 --> 00:36:51,550

762
00:36:51,550 --> 00:36:56,170
>> This first one here means
that it's a pointer 2x.

763
00:36:56,170 --> 00:36:56,740
Right?

764
00:36:56,740 --> 00:36:57,628
It's some pointer x.

765
00:36:57,628 --> 00:36:58,852

766
00:36:58,852 --> 00:37:00,940
x may be something, whatever.

767
00:37:00,940 --> 00:37:01,960

768
00:37:01,960 --> 00:37:05,130
Whatever x is-- say x is four.

769
00:37:05,130 --> 00:37:07,280
It's going to store the
memory address here.

770
00:37:07,280 --> 00:37:12,260
So int, star, x-- this is
some other slot in memory--

771
00:37:12,260 --> 00:37:13,590
who knows what this is.

772
00:37:13,590 --> 00:37:15,430
But it's going to store an address here.

773
00:37:15,430 --> 00:37:27,040
So this would be like--
in this case, Whatever,

774
00:37:27,040 --> 00:37:32,630
is stored at 0x1-- whatever is stored
at the address that our pointer holds,

775
00:37:32,630 --> 00:37:35,280
has to match up with
what we've designated.

776
00:37:35,280 --> 00:37:40,330
So at 0x1, in this case, this is x.

777
00:37:40,330 --> 00:37:42,500

778
00:37:42,500 --> 00:37:49,340
This can only ever be a
int while we're using this.

779
00:37:49,340 --> 00:37:52,950
>> Similarly, if we have
another 1y, whatever

780
00:37:52,950 --> 00:37:59,130
address is stored with a y has
to be a char-- same thing with z.

781
00:37:59,130 --> 00:38:05,840
In the same way, whenever you
try and do intx equals 0.4,

782
00:38:05,840 --> 00:38:09,275
it's going to yell at you and be
like no, you said you wanted an int.

783
00:38:09,275 --> 00:38:10,525
This is supposed to be an int.

784
00:38:10,525 --> 00:38:11,900
Stop trying to make it a float.

785
00:38:11,900 --> 00:38:14,150
>> So let things be what they want to be.

786
00:38:14,150 --> 00:38:15,159

787
00:38:15,159 --> 00:38:16,200
Let things be themselves.

788
00:38:16,200 --> 00:38:19,380

789
00:38:19,380 --> 00:38:23,450
So big thing is just
whatever type of pointer

790
00:38:23,450 --> 00:38:26,101
it is, that's the only
thing you can store there.

791
00:38:26,101 --> 00:38:26,600
OK?

792
00:38:26,600 --> 00:38:27,910

793
00:38:27,910 --> 00:38:31,160
With practice, as with
last week, everything

794
00:38:31,160 --> 00:38:32,817
seems really kind of abstract.

795
00:38:32,817 --> 00:38:34,150
We're going to do some practice.

796
00:38:34,150 --> 00:38:36,760
It should make more sense.

797
00:38:36,760 --> 00:38:44,580
>> So referencing and dereferencing-- it's
really important to get these straight.

798
00:38:44,580 --> 00:38:46,630
I still have to refresh
every now and then.

799
00:38:46,630 --> 00:38:48,450
And I'm like wait, which one do I want?

800
00:38:48,450 --> 00:38:56,080
So the ampersand will actually give
you the reference or address of.

801
00:38:56,080 --> 00:39:00,100
So it returns the address in
memory of which variable is stored.

802
00:39:00,100 --> 00:39:01,170

803
00:39:01,170 --> 00:39:07,020
So it's going to actually return to you
a hexadecimal, whereas dereferencing it

804
00:39:07,020 --> 00:39:10,641
is actually going to give you
the data that is stored there.

805
00:39:10,641 --> 00:39:11,140
OK?

806
00:39:11,140 --> 00:39:12,680

807
00:39:12,680 --> 00:39:16,060
So we're going to look at an example
really fast, or actually up next.

808
00:39:16,060 --> 00:39:18,050

809
00:39:18,050 --> 00:39:19,150
>> OK.

810
00:39:19,150 --> 00:39:21,790
So we have to think really
carefully about this.

811
00:39:21,790 --> 00:39:23,860
So here we have some integer x.

812
00:39:23,860 --> 00:39:26,485
I'm going to try and draw this
out to the best of my abilities.

813
00:39:26,485 --> 00:39:30,230

814
00:39:30,230 --> 00:39:32,410
So we're going to have this slot x.

815
00:39:32,410 --> 00:39:35,850

816
00:39:35,850 --> 00:39:37,315
And it's storing five.

817
00:39:37,315 --> 00:39:38,640

818
00:39:38,640 --> 00:39:40,090
Its address is 0x4.

819
00:39:40,090 --> 00:39:41,920

820
00:39:41,920 --> 00:39:43,160
Cool?

821
00:39:43,160 --> 00:39:44,100
All good.

822
00:39:44,100 --> 00:39:45,470
>> So now we have this pointer.

823
00:39:45,470 --> 00:39:46,916

824
00:39:46,916 --> 00:39:47,990
It was over here.

825
00:39:47,990 --> 00:39:52,130

826
00:39:52,130 --> 00:39:57,560
And the ampersand gives us
the address of something.

827
00:39:57,560 --> 00:40:00,780
So, in this case, it's the address of x.

828
00:40:00,780 --> 00:40:01,875
What is the address of x?

829
00:40:01,875 --> 00:40:05,660

830
00:40:05,660 --> 00:40:12,590
04-- and this pointer is at 0x08.

831
00:40:12,590 --> 00:40:14,490

832
00:40:14,490 --> 00:40:14,990
Cool?

833
00:40:14,990 --> 00:40:16,570

834
00:40:16,570 --> 00:40:21,570
So you can think about this
pointer, 04, just points over here.

835
00:40:21,570 --> 00:40:22,840

836
00:40:22,840 --> 00:40:25,740
And they're called pointers
because as we get more into this,

837
00:40:25,740 --> 00:40:28,450
you're going to see pointing to things.

838
00:40:28,450 --> 00:40:31,470
And one block pointing to another
block will make a lot more sense.

839
00:40:31,470 --> 00:40:32,760

840
00:40:32,760 --> 00:40:33,890
So here are two.

841
00:40:33,890 --> 00:40:38,230
And then we have some
copy, which is what-- 0x0c.

842
00:40:38,230 --> 00:40:41,290

843
00:40:41,290 --> 00:40:43,420
And it's going to
dereference our pointer.

844
00:40:43,420 --> 00:40:46,790
>> So what it's saying is
OK, here's our pointer.

845
00:40:46,790 --> 00:40:53,090
The value it stores is 0x04, And what
it's saying is go to this address

846
00:40:53,090 --> 00:40:54,300
and tell me what's in it.

847
00:40:54,300 --> 00:40:55,520

848
00:40:55,520 --> 00:40:57,710
So that's effectively
what this arrow is doing.

849
00:40:57,710 --> 00:40:58,750

850
00:40:58,750 --> 00:41:01,280
You can think of this like your star.

851
00:41:01,280 --> 00:41:05,410
So OK, when we do star, it means follow.

852
00:41:05,410 --> 00:41:06,810
Go to this address.

853
00:41:06,810 --> 00:41:11,430
And that's basically just following
this arrow to this memory chunk.

854
00:41:11,430 --> 00:41:15,380
And give us what's in it, which is 5.

855
00:41:15,380 --> 00:41:18,840
It's why our copy is equal to 5.

856
00:41:18,840 --> 00:41:20,120
Does that make sense?

857
00:41:20,120 --> 00:41:22,769
Does anyone need me to go through
that again, or more slowly?

858
00:41:22,769 --> 00:41:24,560
You want me to go
through it one more time?

859
00:41:24,560 --> 00:41:25,060
OK.

860
00:41:25,060 --> 00:41:27,549

861
00:41:27,549 --> 00:41:28,840
We're going to redraw it again.

862
00:41:28,840 --> 00:41:31,930

863
00:41:31,930 --> 00:41:37,205
When we start, we all agree we have
some chunk of memory that's a variable

864
00:41:37,205 --> 00:41:40,890
x that we set equal to 5.

865
00:41:40,890 --> 00:41:42,910
We don't control where it is in memory.

866
00:41:42,910 --> 00:41:45,520
So this spot is just
arbitrarily assigned.

867
00:41:45,520 --> 00:41:47,770

868
00:41:47,770 --> 00:41:48,731
Good there?

869
00:41:48,731 --> 00:41:49,230
OK.

870
00:41:49,230 --> 00:41:50,420

871
00:41:50,420 --> 00:41:53,330
Then we initialize a pointer to an int.

872
00:41:53,330 --> 00:41:56,900
That's why it's allowed to point to
x because we have an int in here.

873
00:41:56,900 --> 00:42:00,840
We have another chunk of
memory because this pointer

874
00:42:00,840 --> 00:42:03,485
is a variable just like anything else.

875
00:42:03,485 --> 00:42:06,615
It's arbitrarily assigned
some space in memory.

876
00:42:06,615 --> 00:42:07,630

877
00:42:07,630 --> 00:42:10,830
And what it stores is the address of x.

878
00:42:10,830 --> 00:42:13,200
Ampersand means address of x.

879
00:42:13,200 --> 00:42:14,575
So what is the address of x?

880
00:42:14,575 --> 00:42:19,179

881
00:42:19,179 --> 00:42:20,614
>> AUDIENCE: It's zero--

882
00:42:20,614 --> 00:42:21,280
SPEAKER 1: 0x04.

883
00:42:21,280 --> 00:42:24,350

884
00:42:24,350 --> 00:42:25,940
So then-- last one.

885
00:42:25,940 --> 00:42:30,650
We have some copy-- again
just another variable.

886
00:42:30,650 --> 00:42:32,520
So let's assign some arbitrary place.

887
00:42:32,520 --> 00:42:35,260

888
00:42:35,260 --> 00:42:38,080
And we dereference our pointer.

889
00:42:38,080 --> 00:42:42,490
The star means go to the
address stored in my pointer.

890
00:42:42,490 --> 00:42:44,480
Tell me what's there.

891
00:42:44,480 --> 00:42:47,290
So the address stored
in our pointer is 0x04.

892
00:42:47,290 --> 00:42:49,070

893
00:42:49,070 --> 00:42:51,310
So we go to that address.

894
00:42:51,310 --> 00:42:52,402

895
00:42:52,402 --> 00:42:54,590
It's pointing to that address.

896
00:42:54,590 --> 00:42:57,481
What's inside this memory block?

897
00:42:57,481 --> 00:42:57,980
It's a five.

898
00:42:57,980 --> 00:42:59,210

899
00:42:59,210 --> 00:43:01,650
So that's what we assign our copy.

900
00:43:01,650 --> 00:43:03,430

901
00:43:03,430 --> 00:43:04,860
Everyone good?

902
00:43:04,860 --> 00:43:05,360
Cool.

903
00:43:05,360 --> 00:43:07,010

904
00:43:07,010 --> 00:43:08,330
Again-- pictures.

905
00:43:08,330 --> 00:43:19,750

906
00:43:19,750 --> 00:43:25,200
>> So tracking the values here-- I'm
going to let you guys think about this.

907
00:43:25,200 --> 00:43:26,550

908
00:43:26,550 --> 00:43:27,750
We can draw another picture.

909
00:43:27,750 --> 00:43:31,260
But I want you to try and reason
through this on your own for a minute.

910
00:43:31,260 --> 00:44:01,430

911
00:44:01,430 --> 00:44:04,149
>> Since they didn't give
us an example address,

912
00:44:04,149 --> 00:44:06,940
I'm just going to do ampersand x--
which should help drive it home.

913
00:44:06,940 --> 00:44:07,950
Ampersand means address.

914
00:44:07,950 --> 00:44:09,540

915
00:44:09,540 --> 00:44:12,360
>> So in the first one, everyone
go with the first line.

916
00:44:12,360 --> 00:44:15,690
Some x set's five-- some
random slot in memory.

917
00:44:15,690 --> 00:44:17,660

918
00:44:17,660 --> 00:44:23,200
Int star pointer is equal
to the address of x, right?

919
00:44:23,200 --> 00:44:28,180
Int star pointer creates
this block, calls it pointer,

920
00:44:28,180 --> 00:44:30,650
and assigns it to the address of x.

921
00:44:30,650 --> 00:44:32,750

922
00:44:32,750 --> 00:44:34,230
I'm terrible at ampersands.

923
00:44:34,230 --> 00:44:36,460

924
00:44:36,460 --> 00:44:40,550
>> Now what we're doing is we say
OK, dereference our pointer.

925
00:44:40,550 --> 00:44:42,760
So we go OK, what's in our pointer?

926
00:44:42,760 --> 00:44:44,820
It's ampersand x.

927
00:44:44,820 --> 00:44:49,400
Go to ampersand x and reassign it.

928
00:44:49,400 --> 00:44:51,620

929
00:44:51,620 --> 00:44:57,480
>> So now, ampersand x is going to be 35.

930
00:44:57,480 --> 00:45:01,540

931
00:45:01,540 --> 00:45:05,174
So basically, when you're
dereferencing, you go OK.

932
00:45:05,174 --> 00:45:07,090
You're going to be drawing
pictures like this.

933
00:45:07,090 --> 00:45:09,423
You're going to be drawing
your arrows over where it is.

934
00:45:09,423 --> 00:45:16,030
So go to this slot in memory and either
give me that value back, or alter it.

935
00:45:16,030 --> 00:45:21,620
In this case, because we're at this
value, we're assigning it to be 35.

936
00:45:21,620 --> 00:45:24,700
Whereas in the last
one, if you notice, we

937
00:45:24,700 --> 00:45:27,680
were assigning what was
in here to something else.

938
00:45:27,680 --> 00:45:30,450

939
00:45:30,450 --> 00:45:32,245
>> So they have this awesome table.

940
00:45:32,245 --> 00:45:35,000

941
00:45:35,000 --> 00:45:36,890
It's not that bad.

942
00:45:36,890 --> 00:45:37,970
You guys work on it.

943
00:45:37,970 --> 00:45:39,640
I'm going to draw it out on the board.

944
00:45:39,640 --> 00:45:41,306
We're going to fill it out together, OK?

945
00:45:41,306 --> 00:45:42,290

946
00:45:42,290 --> 00:45:45,530
So grab some paper, grab
a partner, start working.

947
00:45:45,530 --> 00:45:53,897

948
00:45:53,897 --> 00:45:55,605
I'm going to get a
bigger piece of chalk.

949
00:45:55,605 --> 00:45:56,624

950
00:45:56,624 --> 00:45:58,150
Because it's going to be a lot.

951
00:45:58,150 --> 00:45:59,410

952
00:45:59,410 --> 00:45:59,910
OK.

953
00:45:59,910 --> 00:48:08,567

954
00:48:08,567 --> 00:48:09,150
PROFESSOR: OK.

955
00:48:09,150 --> 00:48:11,599

956
00:48:11,599 --> 00:48:12,890
Let's start with the first row.

957
00:48:12,890 --> 00:48:14,070

958
00:48:14,070 --> 00:48:16,970
We'll start there, then you guys
can maybe work through some more.

959
00:48:16,970 --> 00:48:17,870
OK.

960
00:48:17,870 --> 00:48:19,810
a equals b times c so what is a?

961
00:48:19,810 --> 00:48:21,420

962
00:48:21,420 --> 00:48:23,260
It's not a trick question, I promise.

963
00:48:23,260 --> 00:48:24,440
>> STUDENT: 4 times 5.

964
00:48:24,440 --> 00:48:25,420
>> PROFESSOR: 4 times 5.

965
00:48:25,420 --> 00:48:25,920
20.

966
00:48:25,920 --> 00:48:26,730
So what's b?

967
00:48:26,730 --> 00:48:27,921

968
00:48:27,921 --> 00:48:28,420
STUDENT: 4.

969
00:48:28,420 --> 00:48:30,204

970
00:48:30,204 --> 00:48:31,043
>> PROFESSOR: And c?

971
00:48:31,043 --> 00:48:31,542
STUDENT: 5.

972
00:48:31,542 --> 00:48:32,083
PROFESSOR: 5.

973
00:48:32,083 --> 00:48:35,960
And then this is just going to
be ampersand a, ampersand b,

974
00:48:35,960 --> 00:48:38,575
ampersand c, right?

975
00:48:38,575 --> 00:48:39,728

976
00:48:39,728 --> 00:48:40,596
Not bad.

977
00:48:40,596 --> 00:48:42,081
It's simple enough.

978
00:48:42,081 --> 00:48:42,580
OK.

979
00:48:42,580 --> 00:48:44,300
So the next one.

980
00:48:44,300 --> 00:48:48,725
A equals a times c, in case
anyone was unfamiliar with that.

981
00:48:48,725 --> 00:48:49,812

982
00:48:49,812 --> 00:48:53,300
Is everyone familiar
with the times equals?

983
00:48:53,300 --> 00:49:00,105
OK, all this means-- this is
shorthand for a equals a times c.

984
00:49:00,105 --> 00:49:04,840
You can also do it with division,
with addition, with subtraction.

985
00:49:04,840 --> 00:49:12,130
You can do a equals, or a plus equals c
means a equals a plus c, a minus equal

986
00:49:12,130 --> 00:49:15,190
c would be a equals a minus c.

987
00:49:15,190 --> 00:49:16,690
It's just syntactic sugar.

988
00:49:16,690 --> 00:49:19,380

989
00:49:19,380 --> 00:49:24,140
>> So, in this case, a is equal to
a times c would give us what?

990
00:49:24,140 --> 00:49:25,910

991
00:49:25,910 --> 00:49:28,186
Again, not a trick question.

992
00:49:28,186 --> 00:49:28,965
>> STUDENT: 100.

993
00:49:28,965 --> 00:49:29,300
>> PROFESSOR: 100.

994
00:49:29,300 --> 00:49:30,383
Does anything else change?

995
00:49:30,383 --> 00:49:31,790

996
00:49:31,790 --> 00:49:32,290
No.

997
00:49:32,290 --> 00:49:37,380

998
00:49:37,380 --> 00:49:39,850
Maybe I will finally get
better at my ampersands.

999
00:49:39,850 --> 00:49:42,047
>> STUDENT: OK, sorry, how did you get 100?

1000
00:49:42,047 --> 00:49:42,630
PROFESSOR: OK.

1001
00:49:42,630 --> 00:49:46,594
So a is equal to a
times c, so a times c.

1002
00:49:46,594 --> 00:49:48,510
STUDENT: Oh, you're using
a for the previous--

1003
00:49:48,510 --> 00:49:49,135
PROFESSOR: Yes.

1004
00:49:49,135 --> 00:49:51,450
So these are our most recent values.

1005
00:49:51,450 --> 00:49:53,990
These are what you should be
using as we move down, OK.

1006
00:49:53,990 --> 00:49:57,290

1007
00:49:57,290 --> 00:50:01,520
So, b is the only thing changing, right?

1008
00:50:01,520 --> 00:50:02,910
So let's fill in everything else.

1009
00:50:02,910 --> 00:50:09,110

1010
00:50:09,110 --> 00:50:11,330
B. What is b going to be?

1011
00:50:11,330 --> 00:50:13,020

1012
00:50:13,020 --> 00:50:14,140
To be or not to be.

1013
00:50:14,140 --> 00:50:18,680

1014
00:50:18,680 --> 00:50:20,240
So what is this doing?

1015
00:50:20,240 --> 00:50:21,605
What is the star pa doing?

1016
00:50:21,605 --> 00:50:23,280

1017
00:50:23,280 --> 00:50:25,350
>> STUDENT: Code to the location of pa.

1018
00:50:25,350 --> 00:50:26,390

1019
00:50:26,390 --> 00:50:27,480
>> STUDENT: No, not quite.

1020
00:50:27,480 --> 00:50:29,470
So this is a d reference.

1021
00:50:29,470 --> 00:50:31,580
>> STUDENT: So b is handed value of pa.

1022
00:50:31,580 --> 00:50:37,340
>> PROFESSOR: Yeah, so pa is
the address of a, right?

1023
00:50:37,340 --> 00:50:42,430
So it's saying go to where a is
stored and give it that value.

1024
00:50:42,430 --> 00:50:43,884
So what is b?

1025
00:50:43,884 --> 00:50:44,425
STUDENT: 100.

1026
00:50:44,425 --> 00:50:46,534
PROFESSOR: 100.

1027
00:50:46,534 --> 00:50:47,450
Perfect.

1028
00:50:47,450 --> 00:50:49,879
OK, so pc is what's changing.

1029
00:50:49,879 --> 00:50:51,170
Everything else stays the same.

1030
00:50:51,170 --> 00:50:57,160

1031
00:50:57,160 --> 00:50:58,620
What is pc going to be?

1032
00:50:58,620 --> 00:51:00,770

1033
00:51:00,770 --> 00:51:01,580
Simple assignment.

1034
00:51:01,580 --> 00:51:03,520

1035
00:51:03,520 --> 00:51:05,990
Pc is equal to pa, and what is pa?

1036
00:51:05,990 --> 00:51:07,049
>> STUDENT: Ampersand a.

1037
00:51:07,049 --> 00:51:07,840
PROFESSOR: Perfect.

1038
00:51:07,840 --> 00:51:09,490

1039
00:51:09,490 --> 00:51:10,740
Now we're getting interesting.

1040
00:51:10,740 --> 00:51:12,310

1041
00:51:12,310 --> 00:51:15,230
OK, let's break this one down.

1042
00:51:15,230 --> 00:51:21,110
First, what's b times c, because that's
the easy part of this one, right?

1043
00:51:21,110 --> 00:51:22,360
B times c is--

1044
00:51:22,360 --> 00:51:23,320
>> STUDENT: 500.

1045
00:51:23,320 --> 00:51:28,880
>> PROFESSOR: Yeah, so
what is this one doing,

1046
00:51:28,880 --> 00:51:33,705
if it's star pb, what's changing?

1047
00:51:33,705 --> 00:51:35,320

1048
00:51:35,320 --> 00:51:37,242
>> STUDENT: What's in the--

1049
00:51:37,242 --> 00:51:38,200
PROFESSOR: What's in b?

1050
00:51:38,200 --> 00:51:41,340
STUDENT: What's in the space
that pb is pointing to.

1051
00:51:41,340 --> 00:51:43,406
PROFESSOR: And pb is pointing to--

1052
00:51:43,406 --> 00:51:43,905
STUDENT: B.

1053
00:51:43,905 --> 00:51:46,740
PROFESSOR: B. So the only
thing changing is b, right.

1054
00:51:46,740 --> 00:51:50,800
So b times c, 500.

1055
00:51:50,800 --> 00:51:52,367
So that's what changes now.

1056
00:51:52,367 --> 00:51:59,091

1057
00:51:59,091 --> 00:51:59,590
Cool.

1058
00:51:59,590 --> 00:52:00,340

1059
00:52:00,340 --> 00:52:00,840
Lovely.

1060
00:52:00,840 --> 00:52:01,905
You guys are doing great.

1061
00:52:01,905 --> 00:52:03,650

1062
00:52:03,650 --> 00:52:06,740
All right, breaking this one down.

1063
00:52:06,740 --> 00:52:08,050

1064
00:52:08,050 --> 00:52:09,630
C is changing, right?

1065
00:52:09,630 --> 00:52:11,530
So we can fill in everything else.

1066
00:52:11,530 --> 00:52:12,540

1067
00:52:12,540 --> 00:52:13,205
Let's see.

1068
00:52:13,205 --> 00:52:19,125

1069
00:52:19,125 --> 00:52:19,625
OK.

1070
00:52:19,625 --> 00:52:21,420

1071
00:52:21,420 --> 00:52:24,740
We know that c is going to be the
product of two numbers, right?

1072
00:52:24,740 --> 00:52:26,290

1073
00:52:26,290 --> 00:52:27,980
What two numbers, though?

1074
00:52:27,980 --> 00:52:28,970
>> STUDENT: A and c?

1075
00:52:28,970 --> 00:52:31,930
>> PROFESSOR: So a is
right for the first one.

1076
00:52:31,930 --> 00:52:34,385
So we're d referencing p of a, right?

1077
00:52:34,385 --> 00:52:35,390

1078
00:52:35,390 --> 00:52:42,870
P of a points to a, so we know that
this is going to be 100 times what?

1079
00:52:42,870 --> 00:52:46,232
Times what does pc point to?

1080
00:52:46,232 --> 00:52:47,410

1081
00:52:47,410 --> 00:52:48,740
Points to a.

1082
00:52:48,740 --> 00:52:55,038
So 100 times 100 is 10,000.

1083
00:52:55,038 --> 00:52:56,170
Does that makes sense?

1084
00:52:56,170 --> 00:52:57,640

1085
00:52:57,640 --> 00:52:58,200
Cool.

1086
00:52:58,200 --> 00:53:00,500
Home stretch, guys, last row.

1087
00:53:00,500 --> 00:53:01,190
OK.

1088
00:53:01,190 --> 00:53:02,160
What's changing here?

1089
00:53:02,160 --> 00:53:05,640

1090
00:53:05,640 --> 00:53:06,935
>> STUDENT: A.

1091
00:53:06,935 --> 00:53:09,435
PROFESSOR: A. Perfect, so
everything else can stay the same.

1092
00:53:09,435 --> 00:53:16,210

1093
00:53:16,210 --> 00:53:16,710
OK.

1094
00:53:16,710 --> 00:53:17,970
And what is a?

1095
00:53:17,970 --> 00:53:23,610

1096
00:53:23,610 --> 00:53:26,060
So it's a times what?

1097
00:53:26,060 --> 00:53:27,120
This is star pb.

1098
00:53:27,120 --> 00:53:29,750

1099
00:53:29,750 --> 00:53:34,490
So star pb means here's
pb, pb points to b.

1100
00:53:34,490 --> 00:53:35,370
>> STUDENT: 500.

1101
00:53:35,370 --> 00:53:36,230
>> PROFESSOR: 500.

1102
00:53:36,230 --> 00:53:39,236
So we have 500 times 100.

1103
00:53:39,236 --> 00:53:41,758
That's 50,000.

1104
00:53:41,758 --> 00:53:43,216
Whew!

1105
00:53:43,216 --> 00:53:45,646
Look at that.

1106
00:53:45,646 --> 00:53:47,982
>> STUDENT: Why do we have
the &c for the last--

1107
00:53:47,982 --> 00:53:48,690
PROFESSOR: Sorry.

1108
00:53:48,690 --> 00:53:50,080
STUDENT: Oh, OK.

1109
00:53:50,080 --> 00:53:51,600
PROFESSOR: My bad.

1110
00:53:51,600 --> 00:53:52,890
Lots of writing.

1111
00:53:52,890 --> 00:53:53,917

1112
00:53:53,917 --> 00:53:54,500
Everyone good?

1113
00:53:54,500 --> 00:53:55,630

1114
00:53:55,630 --> 00:53:56,660
Not too bad, right?

1115
00:53:56,660 --> 00:53:58,490
Just takes a little
while to work through.

1116
00:53:58,490 --> 00:54:01,080
If you break it down,
understand what each part

1117
00:54:01,080 --> 00:54:03,197
is referring to-- as
with everything it's,

1118
00:54:03,197 --> 00:54:05,780
yes-- break it down to the little
problems and then recombine,

1119
00:54:05,780 --> 00:54:07,345
and you can do some awesome stuff.

1120
00:54:07,345 --> 00:54:08,970
There are the answers, but we did that.

1121
00:54:08,970 --> 00:54:10,324

1122
00:54:10,324 --> 00:54:11,115
Pointer arithmetic.

1123
00:54:11,115 --> 00:54:13,961

1124
00:54:13,961 --> 00:54:14,460
Ah.

1125
00:54:14,460 --> 00:54:15,510
My hands are all chalky.

1126
00:54:15,510 --> 00:54:17,970
So adding or subtracting
int adjusts the pointer

1127
00:54:17,970 --> 00:54:21,890
by the size of the type of pointer.

1128
00:54:21,890 --> 00:54:22,940

1129
00:54:22,940 --> 00:54:28,390
Remember how every type
has a different size?

1130
00:54:28,390 --> 00:54:34,890
So like a double or a long long is
eight and int is four but char is one.

1131
00:54:34,890 --> 00:54:38,360
>> So what you want to do
is-- one thing to remember

1132
00:54:38,360 --> 00:54:44,080
is just that how much your
pointer value actually changes

1133
00:54:44,080 --> 00:54:46,550
will depend on the
type of pointer it is.

1134
00:54:46,550 --> 00:54:50,820

1135
00:54:50,820 --> 00:54:51,820
Everyone good with this?

1136
00:54:51,820 --> 00:54:52,760
Can I erase it?

1137
00:54:52,760 --> 00:54:53,440
We're good?

1138
00:54:53,440 --> 00:54:53,940
Awesome.

1139
00:54:53,940 --> 00:55:01,020

1140
00:55:01,020 --> 00:55:07,501
>> So if we have some pointer
that-- this is going to be-- I'm

1141
00:55:07,501 --> 00:55:08,834
going to make it an int pointer.

1142
00:55:08,834 --> 00:55:10,610

1143
00:55:10,610 --> 00:55:12,760
It stores this.

1144
00:55:12,760 --> 00:55:14,210

1145
00:55:14,210 --> 00:55:20,170
If you were to say pointer
plus one, what it's going to do

1146
00:55:20,170 --> 00:55:23,420
is it's going to update
it by the size of an int

1147
00:55:23,420 --> 00:55:25,950
because that's the
type of pointer it is.

1148
00:55:25,950 --> 00:55:28,260
>> With C, everything is
very strict and regulated.

1149
00:55:28,260 --> 00:55:29,440

1150
00:55:29,440 --> 00:55:35,260
The int pointer is going to update by
the amount of space an int would take.

1151
00:55:35,260 --> 00:55:36,260
An int is four bytes.

1152
00:55:36,260 --> 00:55:37,650

1153
00:55:37,650 --> 00:55:39,060
>> So what would this turn into?

1154
00:55:39,060 --> 00:55:40,876

1155
00:55:40,876 --> 00:55:44,390
You're just adding four onto this.

1156
00:55:44,390 --> 00:55:50,040
Now your pointer would be-- OK.

1157
00:55:50,040 --> 00:55:51,820

1158
00:55:51,820 --> 00:55:55,380
>> So if it was a char and we did pointer
plus one, what would it be now?

1159
00:55:55,380 --> 00:56:00,300

1160
00:56:00,300 --> 00:56:03,330
If it started-- pretending we
started-- right now it's 0x08.

1161
00:56:03,330 --> 00:56:04,850

1162
00:56:04,850 --> 00:56:10,850
Let's now say that this was a
char pointer, and we added one.

1163
00:56:10,850 --> 00:56:11,850
What would it change to?

1164
00:56:11,850 --> 00:56:14,989

1165
00:56:14,989 --> 00:56:16,030
How many bytes is a char?

1166
00:56:16,030 --> 00:56:16,680
>> AUDIENCE: One.

1167
00:56:16,680 --> 00:56:17,304
>> SPEAKER 1: One.

1168
00:56:17,304 --> 00:56:18,309
AUDIENCE: So 0x09.

1169
00:56:18,309 --> 00:56:19,600
SPEAKER 1: So it would be nine.

1170
00:56:19,600 --> 00:56:22,571

1171
00:56:22,571 --> 00:56:23,820
So just something to remember.

1172
00:56:23,820 --> 00:56:28,340
Just when you add one, it's not
adding one unless it's a char.

1173
00:56:28,340 --> 00:56:34,190
It's adding how many
bytes the type that it is,

1174
00:56:34,190 --> 00:56:36,960
which is why we have
this equation up here.

1175
00:56:36,960 --> 00:56:40,190
So it's int times the size
of the type of pointer.

1176
00:56:40,190 --> 00:56:42,850

1177
00:56:42,850 --> 00:56:44,730
>> So we have the example here.

1178
00:56:44,730 --> 00:56:47,250

1179
00:56:47,250 --> 00:56:54,430
y was assigned to that value, 0x4,
when we did y plus equals one.

1180
00:56:54,430 --> 00:56:56,830
What's in it, what's
in x, doesn't change.

1181
00:56:56,830 --> 00:56:58,610
What does change is what's in y.

1182
00:56:58,610 --> 00:57:04,980
The address stored in y updated by four
because there are four bytes in an int

1183
00:57:04,980 --> 00:57:06,097
and it's an int pointer.

1184
00:57:06,097 --> 00:57:07,290

1185
00:57:07,290 --> 00:57:07,790
>> All right.

1186
00:57:07,790 --> 00:57:09,123
So now we have another exercise.

1187
00:57:09,123 --> 00:57:11,140

1188
00:57:11,140 --> 00:57:13,500
So the question is what will print.

1189
00:57:13,500 --> 00:57:36,710

1190
00:57:36,710 --> 00:57:37,650
Any ideas?

1191
00:57:37,650 --> 00:57:41,690

1192
00:57:41,690 --> 00:57:43,699
>> AUDIENCE: The number of
characters in happy cat?

1193
00:57:43,699 --> 00:57:44,490
SPEAKER 1: Exactly.

1194
00:57:44,490 --> 00:57:45,531
So like with your string.

1195
00:57:45,531 --> 00:57:47,302

1196
00:57:47,302 --> 00:57:48,260
Does everyone get that?

1197
00:57:48,260 --> 00:57:49,509
Do we want to walk through it?

1198
00:57:49,509 --> 00:57:50,300

1199
00:57:50,300 --> 00:57:52,010
>> Yes, OK.

1200
00:57:52,010 --> 00:57:57,385
So what we have here-- I
like this so much more.

1201
00:57:57,385 --> 00:57:59,340
I don't have to
[INAUDIBLE] ridiculously.

1202
00:57:59,340 --> 00:58:01,690
>> So we have our string here, happy cat.

1203
00:58:01,690 --> 00:58:02,950
Lovely.

1204
00:58:02,950 --> 00:58:05,080
We have some counter that
we're keeping track of.

1205
00:58:05,080 --> 00:58:11,430
So we have some char* pointer
that just is set equal to str.

1206
00:58:11,430 --> 00:58:14,320
What this is doing is it's
assigning some pointer

1207
00:58:14,320 --> 00:58:16,380
to the beginning of your string.

1208
00:58:16,380 --> 00:58:19,840
Because I'm sure, as it
was mentioned in lecture,

1209
00:58:19,840 --> 00:58:22,290
we've given you guys this
data type called string.

1210
00:58:22,290 --> 00:58:29,070
>> But really strings are just
an array of-- like char*.

1211
00:58:29,070 --> 00:58:32,330
It's a pointer to a bunch of characters
that are contiguous in memory.

1212
00:58:32,330 --> 00:58:33,680

1213
00:58:33,680 --> 00:58:36,280
So this just sets it
equal to any string is

1214
00:58:36,280 --> 00:58:38,980
identified by where
its first character is.

1215
00:58:38,980 --> 00:58:42,710
So this is just setting some point
equal to the beginning of the string.

1216
00:58:42,710 --> 00:58:44,130
Everyone good there?

1217
00:58:44,130 --> 00:58:44,960
Cool.

1218
00:58:44,960 --> 00:58:49,840
>> So this is dereferencing our pointer.

1219
00:58:49,840 --> 00:58:53,760
So it's actually going to
give us some value in here,

1220
00:58:53,760 --> 00:58:55,610
in our string that we're talking about.

1221
00:58:55,610 --> 00:58:58,342
And we're saying as long as
it's not null terminator.

1222
00:58:58,342 --> 00:59:00,550
So keep going until you get
to the end of the string.

1223
00:59:00,550 --> 00:59:02,180

1224
00:59:02,180 --> 00:59:04,190
Update your pointer by one.

1225
00:59:04,190 --> 00:59:09,250
So r, it will actually update by one
each time because this is a char,

1226
00:59:09,250 --> 00:59:09,820
the char*.

1227
00:59:09,820 --> 00:59:10,930

1228
00:59:10,930 --> 00:59:12,340
>> So it's going to go through.

1229
00:59:12,340 --> 00:59:13,290
It's going to update.

1230
00:59:13,290 --> 00:59:16,705
So the first time this runs,
it's going to be here at h.

1231
00:59:16,705 --> 00:59:17,590
It's going to update.

1232
00:59:17,590 --> 00:59:18,185
>> It'll be an a.

1233
00:59:18,185 --> 00:59:21,310
It'll be a p, y, and so on and so forth.

1234
00:59:21,310 --> 00:59:22,300
We'll update counter.

1235
00:59:22,300 --> 00:59:26,160
When it reaches the end, it
just prints how far it's gotten.

1236
00:59:26,160 --> 00:59:27,550

1237
00:59:27,550 --> 00:59:28,050
Yes.

1238
00:59:28,050 --> 00:59:31,475
>> AUDIENCE: So It counts
the space as one, right?

1239
00:59:31,475 --> 00:59:31,974
OK.

1240
00:59:31,974 --> 00:59:34,294

1241
00:59:34,294 --> 00:59:35,222
>> SPEAKER 1: Think so.

1242
00:59:35,222 --> 00:59:36,830
Is that a question--

1243
00:59:36,830 --> 00:59:37,746
>> AUDIENCE: [INAUDIBLE].

1244
00:59:37,746 --> 00:59:37,968

1245
00:59:37,968 --> 00:59:38,884
>> SPEAKER 1: No worries.

1246
00:59:38,884 --> 00:59:39,720

1247
00:59:39,720 --> 00:59:42,736
This I do that.

1248
00:59:42,736 --> 00:59:47,710
All right, so one thing I
understand is that with an array,

1249
00:59:47,710 --> 00:59:51,736
you can also treat it as a
pointer because arrays are just

1250
00:59:51,736 --> 00:59:52,860
continuous spots of memory.

1251
00:59:52,860 --> 00:59:53,970

1252
00:59:53,970 --> 00:59:56,380
>> So you can treat it the same way.

1253
00:59:56,380 --> 00:59:59,000
You can manipulate them
with pointers, too.

1254
00:59:59,000 --> 01:00:04,770
So instead of doing, in this
case, the analogous thing

1255
01:00:04,770 --> 01:00:07,490
would be array 0 equals 1.

1256
01:00:07,490 --> 01:00:08,760

1257
01:00:08,760 --> 01:00:15,210
>> But in the same way that
a string is determined

1258
01:00:15,210 --> 01:00:18,740
by the start of where
its first character is,

1259
01:00:18,740 --> 01:00:22,270
an array is determined by
where its first element is.

1260
01:00:22,270 --> 01:00:25,120
Because we know, we're
guaranteed, that these

1261
01:00:25,120 --> 01:00:27,985
are going to be continuous
blocks of memory.

1262
01:00:27,985 --> 01:00:29,360
That's what allows us to do this.

1263
01:00:29,360 --> 01:00:31,193
We know they're continuous
blocks of memory.

1264
01:00:31,193 --> 01:00:32,230

1265
01:00:32,230 --> 01:00:36,500
>> So in this case, by dereferencing
just array, that tells us,

1266
01:00:36,500 --> 01:00:40,800
OK, go to the start of
your array, which is here.

1267
01:00:40,800 --> 01:00:42,640
So you can set it equal to one.

1268
01:00:42,640 --> 01:00:48,610
And in this case, whatever your array
type is, when you update it by one,

1269
01:00:48,610 --> 01:00:50,830
that's just like updating
it to the next index.

1270
01:00:50,830 --> 01:00:52,760

1271
01:00:52,760 --> 01:00:56,360
You can do that because you
know what's in your array.

1272
01:00:56,360 --> 01:00:59,770
So it knows how much to
update your pointer by,

1273
01:00:59,770 --> 01:01:02,925
what address to update it to so
that you're at the next slot.

1274
01:01:02,925 --> 01:01:04,740

1275
01:01:04,740 --> 01:01:09,400
>> So this is just a different way
of writing array 0 equals 1,

1276
01:01:09,400 --> 01:01:15,114
array 1 equals 2, array
bracket 2 equals 3.

1277
01:01:15,114 --> 01:01:16,780
It's just another way to think about it.

1278
01:01:16,780 --> 01:01:19,600
Because they are continuous
blocks in memory,

1279
01:01:19,600 --> 01:01:21,830
you can refer to them either
by the array notation--

1280
01:01:21,830 --> 01:01:24,390
which I personally
find easier-- but maybe

1281
01:01:24,390 --> 01:01:27,347
you need to manipulate it
strictly by memory addresses.

1282
01:01:27,347 --> 01:01:28,930
And this is the way you would do that.

1283
01:01:28,930 --> 01:01:30,630

1284
01:01:30,630 --> 01:01:32,630
Kind of more of like a
cool thing you could do

1285
01:01:32,630 --> 01:01:35,213
versus maybe not something you're
actually going to implement.

1286
01:01:35,213 --> 01:01:36,960

1287
01:01:36,960 --> 01:01:38,630
>> I use it in 61.

1288
01:01:38,630 --> 01:01:41,710
You guys probably don't need
to worry about it too much.

1289
01:01:41,710 --> 01:01:43,693
But if you're interested,
take 61 next year.

1290
01:01:43,693 --> 01:01:45,269

1291
01:01:45,269 --> 01:01:46,560
We're in the home stretch guys.

1292
01:01:46,560 --> 01:01:47,510
I know, it's long.

1293
01:01:47,510 --> 01:01:50,570

1294
01:01:50,570 --> 01:01:58,880
Dynamic Memory Allocation--
so we know that one

1295
01:01:58,880 --> 01:02:01,790
of things when we talked during
our first section together,

1296
01:02:01,790 --> 01:02:04,560
we looked at a swap
function where it was

1297
01:02:04,560 --> 01:02:08,010
outside the scope of our main function.

1298
01:02:08,010 --> 01:02:14,370
And we were passing in these values
that were effectively copies.

1299
01:02:14,370 --> 01:02:20,570
>> And once swap finished
executing, it just left a stack.

1300
01:02:20,570 --> 01:02:22,830
Remember, we have a
stack frame for swap.

1301
01:02:22,830 --> 01:02:26,070
It leaves and those
values leave with it.

1302
01:02:26,070 --> 01:02:27,050
And they were gone.

1303
01:02:27,050 --> 01:02:28,615
We couldn't do anything
with them and we were sad

1304
01:02:28,615 --> 01:02:29,989
because we can't swap our values.

1305
01:02:29,989 --> 01:02:31,070

1306
01:02:31,070 --> 01:02:36,560
>> But with C, as I mentioned, you
have a lot of power over memory.

1307
01:02:36,560 --> 01:02:43,310
So what you can do is you can
allocate things on the heap here

1308
01:02:43,310 --> 01:02:46,830
that will stay there until
you tell them otherwise.

1309
01:02:46,830 --> 01:02:48,280
>> They're like good children.

1310
01:02:48,280 --> 01:02:49,150
They stay there.

1311
01:02:49,150 --> 01:02:50,270
They don't leave.

1312
01:02:50,270 --> 01:02:52,750
They'll stay there until you're
like, OK, you can go away.

1313
01:02:52,750 --> 01:02:55,920
>> Whereas things on the stack, who--
they're like naughty children.

1314
01:02:55,920 --> 01:02:59,160
They'll just run away when you want
to be there and then they're gone.

1315
01:02:59,160 --> 01:03:00,160
You can't get them back.

1316
01:03:00,160 --> 01:03:01,350

1317
01:03:01,350 --> 01:03:07,187
>> So the heap is-- we're going to
talk about malloc and free, which

1318
01:03:07,187 --> 01:03:08,895
I'm sure you guys
heard about in lecture.

1319
01:03:08,895 --> 01:03:10,270

1320
01:03:10,270 --> 01:03:14,210
And that's basically a way
to have very persistent data.

1321
01:03:14,210 --> 01:03:18,920
So you can keep the data
around as long as you want.

1322
01:03:18,920 --> 01:03:19,546
Mhm.

1323
01:03:19,546 --> 01:03:21,475
>> AUDIENCE: Can you define heap and stack?

1324
01:03:21,475 --> 01:03:24,030
Are they like places to put things?

1325
01:03:24,030 --> 01:03:26,630
>> SPEAKER 1: So they're
basically just-- they're

1326
01:03:26,630 --> 01:03:29,530
the way we refer just to memory.

1327
01:03:29,530 --> 01:03:37,300
So heap is just places where
memory is allocated dynamically,

1328
01:03:37,300 --> 01:03:40,960
whereas stack refers
more to stack frames

1329
01:03:40,960 --> 01:03:45,950
that are more central to the
functions that are actually running.

1330
01:03:45,950 --> 01:03:47,200
You don't really have control.

1331
01:03:47,200 --> 01:03:50,690
>> The big difference, you have control
over the heap if you want to.

1332
01:03:50,690 --> 01:03:52,710
You have less control over the stack.

1333
01:03:52,710 --> 01:03:55,030
The stack depends on the
functions that are running,

1334
01:03:55,030 --> 01:03:58,320
and the order in which they are
run, and how things are returned.

1335
01:03:58,320 --> 01:04:01,290
Whereas with the heap, as
we'll see, you can say,

1336
01:04:01,290 --> 01:04:06,639
OK, I want this value to be
around until I tell you otherwise.

1337
01:04:06,639 --> 01:04:08,180
You are not allowed to get rid of it.

1338
01:04:08,180 --> 01:04:09,300
You're not allowed to override it.

1339
01:04:09,300 --> 01:04:11,675
You're going to keep it around
for as long as I tell you.

1340
01:04:11,675 --> 01:04:15,780
You get to be the boss in the heap,
whereas the stack-- maybe if you

1341
01:04:15,780 --> 01:04:18,080
like finagle your way
you can be the boss.

1342
01:04:18,080 --> 01:04:19,340
But not quite.

1343
01:04:19,340 --> 01:04:20,480

1344
01:04:20,480 --> 01:04:22,070
And it's really just memory.

1345
01:04:22,070 --> 01:04:24,260
It's just different ways
of referring to memory.

1346
01:04:24,260 --> 01:04:25,800

1347
01:04:25,800 --> 01:04:26,400
>> Cool.

1348
01:04:26,400 --> 01:04:28,630
So with that, how to
control your memory.

1349
01:04:28,630 --> 01:04:32,070
It's with malloc, which
you're going to get to use.

1350
01:04:32,070 --> 01:04:37,100
So it's just short
for memory allocation.

1351
01:04:37,100 --> 01:04:38,459
That's all it is.

1352
01:04:38,459 --> 01:04:41,250
There's a bunch of other cool
functions that have alloc at the end,

1353
01:04:41,250 --> 01:04:42,750
and they stand for different things.

1354
01:04:42,750 --> 01:04:43,550

1355
01:04:43,550 --> 01:04:49,050
>> So when you need storage that needs
to outlast your current function so

1356
01:04:49,050 --> 01:04:51,010
that when your current
function runs away,

1357
01:04:51,010 --> 01:04:55,774
you still have the data that you
got from it, you want to use malloc.

1358
01:04:55,774 --> 01:04:57,190
That'll initialize it on the heap.

1359
01:04:57,190 --> 01:05:00,140
And like I said and keep
saying, you'll keep it there

1360
01:05:00,140 --> 01:05:03,050
until you tell it otherwise,
which is the important thing here.

1361
01:05:03,050 --> 01:05:08,450
>> So one thing to notice, and
that's typically really important,

1362
01:05:08,450 --> 01:05:13,620
is that this sizeof
is super useful to use

1363
01:05:13,620 --> 01:05:16,440
because depending on the type
of machine you're running,

1364
01:05:16,440 --> 01:05:22,470
it may have varying amounts
of memory that it takes.

1365
01:05:22,470 --> 01:05:26,870
So you always want to use size of so
that you're not machine dependent,

1366
01:05:26,870 --> 01:05:30,300
so that your code will
run on any machine.

1367
01:05:30,300 --> 01:05:32,360
>> And that's just part
of writing good code.

1368
01:05:32,360 --> 01:05:34,610
If it works on one machine,
but not any of the others,

1369
01:05:34,610 --> 01:05:36,440
how useful was your program?

1370
01:05:36,440 --> 01:05:38,420
So you always want to
make sure and use sizeof.

1371
01:05:38,420 --> 01:05:41,306
>> AUDIENCE: So is that like the
size of 10 inches [INAUDIBLE]?

1372
01:05:41,306 --> 01:05:43,698
>> SPEAKER 1: This is the size of 10 ints.

1373
01:05:43,698 --> 01:05:44,197
yeah.

1374
01:05:44,197 --> 01:05:45,360

1375
01:05:45,360 --> 01:05:48,830
So size of ints will return
how much does one int take.

1376
01:05:48,830 --> 01:05:51,530
Or size of char, how
much does one char take.

1377
01:05:51,530 --> 01:05:54,150
And then how many blocks
of that do you want?

1378
01:05:54,150 --> 01:05:57,590
>> So in this case, we want something
that we can store 10 ints to.

1379
01:05:57,590 --> 01:06:00,240
And it will work regardless
of machine, which is cool.

1380
01:06:00,240 --> 01:06:01,720

1381
01:06:01,720 --> 01:06:04,846
So how many bytes will
that actually give you?

1382
01:06:04,846 --> 01:06:06,190
Quick math.

1383
01:06:06,190 --> 01:06:06,787
>> AUDIENCE: 40.

1384
01:06:06,787 --> 01:06:07,370
SPEAKER 1: 40.

1385
01:06:07,370 --> 01:06:07,869
Exactly.

1386
01:06:07,869 --> 01:06:09,520

1387
01:06:09,520 --> 01:06:12,030
So another big thing.

1388
01:06:12,030 --> 01:06:14,840
Pointer or malloc can return null.

1389
01:06:14,840 --> 01:06:17,910
>> So again, always check to
see if it returned null

1390
01:06:17,910 --> 01:06:19,620
before you try and do anything with it.

1391
01:06:19,620 --> 01:06:23,430

1392
01:06:23,430 --> 01:06:27,350
If you try and dereference
this pointer now,

1393
01:06:27,350 --> 01:06:29,720
it's just going to segfault
because you went and tried

1394
01:06:29,720 --> 01:06:31,730
to touch null when you shouldn't have.

1395
01:06:31,730 --> 01:06:34,000
So always check for null.

1396
01:06:34,000 --> 01:06:36,075
Again, all you can do.

1397
01:06:36,075 --> 01:06:38,300

1398
01:06:38,300 --> 01:06:39,720
>> It might return null.

1399
01:06:39,720 --> 01:06:42,740
It'll return null if you're either
out of space, or for whatever reason

1400
01:06:42,740 --> 01:06:44,350
it ran into some memory bug.

1401
01:06:44,350 --> 01:06:45,890

1402
01:06:45,890 --> 01:06:47,510
It sometimes just returns null.

1403
01:06:47,510 --> 01:06:48,990
So you just have to check for it.

1404
01:06:48,990 --> 01:06:51,050
That's all this slide is saying.

1405
01:06:51,050 --> 01:06:53,366

1406
01:06:53,366 --> 01:06:55,240
And then what we have
here is a call to free.

1407
01:06:55,240 --> 01:07:00,550
So in the same way that if you
open a file you must close a file,

1408
01:07:00,550 --> 01:07:04,340
if you malloc memory, you
must you free that memory.

1409
01:07:04,340 --> 01:07:06,530
And you guys will get
to do really cool stuff.

1410
01:07:06,530 --> 01:07:09,624
>> And there's a program you can run to
see if you're ever leaking memory.

1411
01:07:09,624 --> 01:07:11,040
But you don't want to leak memory.

1412
01:07:11,040 --> 01:07:11,820
It's really bad.

1413
01:07:11,820 --> 01:07:13,191

1414
01:07:13,191 --> 01:07:15,020
Just mess up things.

1415
01:07:15,020 --> 01:07:20,939
>> It's bad to do just like programming
wise for design efficiency.

1416
01:07:20,939 --> 01:07:22,980
But it's also just kind
of bad for your computer.

1417
01:07:22,980 --> 01:07:26,780
So just free things
when you malloc them.

1418
01:07:26,780 --> 01:07:28,190

1419
01:07:28,190 --> 01:07:30,210
>> You guys see the symmetries here.

1420
01:07:30,210 --> 01:07:31,180
Super simple.

1421
01:07:31,180 --> 01:07:33,010
Just free and then
whatever your pointer,

1422
01:07:33,010 --> 01:07:34,843
whatever the name of
your pointer is, and it

1423
01:07:34,843 --> 01:07:36,710
will take care of freeing it for you.

1424
01:07:36,710 --> 01:07:38,200

1425
01:07:38,200 --> 01:07:38,700
Cool.

1426
01:07:38,700 --> 01:07:40,410

1427
01:07:40,410 --> 01:07:42,530
>> Then we have this.

1428
01:07:42,530 --> 01:07:44,770
So we're just going to
walk through this program.

1429
01:07:44,770 --> 01:07:46,560
And then you guys are done.

1430
01:07:46,560 --> 01:07:50,240
>> So [INAUDIBLE] just main.

1431
01:07:50,240 --> 01:07:51,690
So we have some int* pointer.

1432
01:07:51,690 --> 01:07:53,648
So we have a pointer
that's going to hold ints.

1433
01:07:53,648 --> 01:07:54,500

1434
01:07:54,500 --> 01:07:56,170
And how many ints is it going to hold?

1435
01:07:56,170 --> 01:07:57,400

1436
01:07:57,400 --> 01:07:58,170
Just one.

1437
01:07:58,170 --> 01:07:59,400

1438
01:07:59,400 --> 01:08:01,100
Size of an int.

1439
01:08:01,100 --> 01:08:03,900
>> We check to see if
pointer is null because it

1440
01:08:03,900 --> 01:08:06,130
is, we want to say don't do anything.

1441
01:08:06,130 --> 01:08:07,065
It's bad.

1442
01:08:07,065 --> 01:08:08,130

1443
01:08:08,130 --> 01:08:12,130
So we print some error out of
memory, most often return 1,

1444
01:08:12,130 --> 01:08:14,260
as you guys are used to.

1445
01:08:14,260 --> 01:08:17,390
>> And then we have here, we
dereference our pointer.

1446
01:08:17,390 --> 01:08:22,840
So that means we're going to store
something at the location given to us.

1447
01:08:22,840 --> 01:08:24,350

1448
01:08:24,350 --> 01:08:30,830
Int* pointer, or malloc, returns the
address of where it set aside this

1449
01:08:30,830 --> 01:08:31,750
memory for you.

1450
01:08:31,750 --> 01:08:32,830

1451
01:08:32,830 --> 01:08:34,800
So it's basically
giving you like-- if you

1452
01:08:34,800 --> 01:08:38,149
think about a bunch of
houses in a neighborhood

1453
01:08:38,149 --> 01:08:40,640
that you want to put
your furniture in, malloc

1454
01:08:40,640 --> 01:08:43,850
is like OK, you get
to go to house three.

1455
01:08:43,850 --> 01:08:45,800
And it gives you the
address of house three.

1456
01:08:45,800 --> 01:08:48,775
>> So this right now, this
pointer stores an address,

1457
01:08:48,775 --> 01:08:50,149
stores the address of your house.

1458
01:08:50,149 --> 01:08:51,470

1459
01:08:51,470 --> 01:08:54,640
*ptr means, OK, I'm at my house.

1460
01:08:54,640 --> 01:08:55,326
Cool.

1461
01:08:55,326 --> 01:08:56,580
I need to get some integer.

1462
01:08:56,580 --> 01:08:59,229
>> So you're asking for someone
to give you furniture now.

1463
01:08:59,229 --> 01:09:00,430
So you get some int.

1464
01:09:00,430 --> 01:09:05,100
And it puts it in your pointer
where it's pointing to.

1465
01:09:05,100 --> 01:09:08,670
>> And then it just prints
out, you entered wherever.

1466
01:09:08,670 --> 01:09:11,060
And again, the reference.

1467
01:09:11,060 --> 01:09:15,649
So this is like you went to this
address and you saw what was there.

1468
01:09:15,649 --> 01:09:17,120

1469
01:09:17,120 --> 01:09:17,630
Cool?

1470
01:09:17,630 --> 01:09:20,174
>> And then of course we free our pointer.

1471
01:09:20,174 --> 01:09:21,590
Don't forget to free your pointer.

1472
01:09:21,590 --> 01:09:22,933
Don't forget to check for null.

1473
01:09:22,933 --> 01:09:24,349
Don't forget to free your pointer.

1474
01:09:24,349 --> 01:09:27,270
You have two things you remember from
this, or that you should remember.

1475
01:09:27,270 --> 01:09:27,770
Yes.

1476
01:09:27,770 --> 01:09:31,590
AUDIENCE: [INAUDIBLE] stuff
like that, the char*s.

1477
01:09:31,590 --> 01:09:33,760
How come we never free those?

1478
01:09:33,760 --> 01:09:34,529
>> SPEAKER 1: Hm?

1479
01:09:34,529 --> 01:09:36,450
>> AUDIENCE: Are those like strings?

1480
01:09:36,450 --> 01:09:39,160
You said strings are
just like char*s, right?

1481
01:09:39,160 --> 01:09:41,200
So why don't we free strings?

1482
01:09:41,200 --> 01:09:43,204
>> SPEAKER 1: You only to
free if you're mallocing.

1483
01:09:43,204 --> 01:09:44,620
AUDIENCE: Oh, if you're mallocing.

1484
01:09:44,620 --> 01:09:47,399
SPEAKER 1: So malloc
and free are two things

1485
01:09:47,399 --> 01:09:49,000
that you should always have together.

1486
01:09:49,000 --> 01:09:51,630
f open, f close, two things
you should have together.

1487
01:09:51,630 --> 01:09:54,471
In both those cases, check for null.

1488
01:09:54,471 --> 01:09:54,971
Yes.

1489
01:09:54,971 --> 01:09:57,130
>> AUDIENCE: So free is just
allowing something else

1490
01:09:57,130 --> 01:09:59,690
to be stored there after
this program has used it?

1491
01:09:59,690 --> 01:10:01,946
>> SPEAKER 1: It's just saying,
OK, I'm done with this.

1492
01:10:01,946 --> 01:10:03,320
You don't need to keep it around.

1493
01:10:03,320 --> 01:10:05,340

1494
01:10:05,340 --> 01:10:08,190
Otherwise your computer will
just like try and keep it there.

1495
01:10:08,190 --> 01:10:10,910
And then you can't-- it runs
into memory issues later.

1496
01:10:10,910 --> 01:10:13,660
You always want to free it because
it tells your computer, OK, I'm

1497
01:10:13,660 --> 01:10:15,190
done with this spot of memory.

1498
01:10:15,190 --> 01:10:17,190
You can have it back
for me to use later.

1499
01:10:17,190 --> 01:10:19,250

1500
01:10:19,250 --> 01:10:20,500
Cool?

1501
01:10:20,500 --> 01:10:21,320
Yes.

1502
01:10:21,320 --> 01:10:26,950
>> AUDIENCE: So we used the %d just
because a double that's coming back,

1503
01:10:26,950 --> 01:10:28,330
or why is-- [INAUDIBLE].

1504
01:10:28,330 --> 01:10:30,170

1505
01:10:30,170 --> 01:10:31,620
>> AUDIENCE: Can you use %i?

1506
01:10:31,620 --> 01:10:32,760
>> SPEAKER 1: You can use %i.

1507
01:10:32,760 --> 01:10:35,052

1508
01:10:35,052 --> 01:10:36,135
Any last minute questions?

1509
01:10:36,135 --> 01:10:38,310

1510
01:10:38,310 --> 01:10:38,985
Go ahead.

1511
01:10:38,985 --> 01:10:40,610
AUDIENCE: I just have a quick question.

1512
01:10:40,610 --> 01:10:50,200
So the ptr variable, that's--
like, with the int* ptr = malloc,

1513
01:10:50,200 --> 01:10:54,142
that's just saying it's
pointing to a place in memory--

1514
01:10:54,142 --> 01:10:55,600
SPEAKER 1: Do you want [INAUDIBLE]?

1515
01:10:55,600 --> 01:10:58,050
AUDIENCE: --that's the
size of-- no, it's OK.

1516
01:10:58,050 --> 01:11:01,292
But it's just pointing to a place in
memory that's just like four bytes.

1517
01:11:01,292 --> 01:11:02,000
SPEAKER 1: Right.

1518
01:11:02,000 --> 01:11:03,030

1519
01:11:03,030 --> 01:11:07,070
So malloc the size of int says,
OK, I'm going to go run off,

1520
01:11:07,070 --> 01:11:08,780
find four bytes of memory for you.

1521
01:11:08,780 --> 01:11:10,700
When it finds that four
bytes of memory, it

1522
01:11:10,700 --> 01:11:14,030
gives you back the address
of where it starts,

1523
01:11:14,030 --> 01:11:16,160
and that's what stored
in pointer, or ptr.

1524
01:11:16,160 --> 01:11:17,510

1525
01:11:17,510 --> 01:11:18,010
Good.

1526
01:11:18,010 --> 01:11:18,742

1527
01:11:18,742 --> 01:11:21,700
You guys look less confused than most
people when I talk about pointer,

1528
01:11:21,700 --> 01:11:23,670
so I'm feeling pretty good right now.

1529
01:11:23,670 --> 01:11:24,520
>> All right.

1530
01:11:24,520 --> 01:11:27,960
As always, you guys should have all
gotten your pset2 grades by now.

1531
01:11:27,960 --> 01:11:32,769
I know there have been some wonky
things where it says, formula not valid

1532
01:11:32,769 --> 01:11:33,310
or something.

1533
01:11:33,310 --> 01:11:36,166
If you're getting that, all of
your grades are valid on my side.

1534
01:11:36,166 --> 01:11:38,040
So I can send you
screenshots of your grades.

1535
01:11:38,040 --> 01:11:39,011

1536
01:11:39,011 --> 01:11:41,760
Just let me know as well if you're
missing any grades or something

1537
01:11:41,760 --> 01:11:43,060
doesn't seem to make sense.

1538
01:11:43,060 --> 01:11:43,720
Come to me.

1539
01:11:43,720 --> 01:11:44,830

1540
01:11:44,830 --> 01:11:48,830
>> I've been super proud of you
guys already, so keep it up.

1541
01:11:48,830 --> 01:11:50,640
And have a good rest of your week.

1542
01:11:50,640 --> 01:11:53,440
I'm sure I'll see some
of you at office hours.

1543
01:11:53,440 --> 01:11:55,414

